"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovementReader = void 0;
const physics_1 = require("./dist/physics/engines/physics");
const nextSim_1 = require("./dist/physics/sims/nextSim");
const prismarine_registry_1 = __importDefault(require("prismarine-registry"));
const vec3_1 = require("vec3");
const util_1 = require("util");
const entityState_1 = require("./dist/physics/states/entityState");
const sleep = (0, util_1.promisify)(setTimeout);
const emptyVec = new vec3_1.Vec3(0, 0, 0);
class MovementReader {
    constructor(bot) {
        this.bot = bot;
        this.trackingData = {};
        this.simStates = {};
        this.tick = 0;
        this.perVelocityUpdateState = (packet) => __awaiter(this, void 0, void 0, function* () {
            if (!this.simStates[packet.entityId])
                return;
            const simInfo = this.simStates[packet.entityId];
            // simInfo.state.velocity = MathUtils.fromNotchVelocity(new Vec3(packet.velocityX, packet.velocityY, packet.velocityZ));
            simInfo.vu = true;
            yield this.bot.waitForTicks(1);
            simInfo.vu = false;
        });
        this.updateStateInfo = (entity) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const entityId = entity.id;
            if (!((_a = this.trackingData[entityId]) === null || _a === void 0 ? void 0 : _a.tracking))
                return;
            if (!this.bot.entities[entityId])
                return;
            const currentEntity = this.bot.entities[entityId]; // wasteful index lookup. More performant than variable storage before return.
            const currentState = entityState_1.EntityState.CREATE_FROM_ENTITY(this.physics, currentEntity);
            const stateInfo = this.trackingData[entityId].states;
            const simState = this.simStates[entity.id].state;
            //update states that have changes unrelated to position changes. Yaw, pitch, etc.
            const previousState = stateInfo[1];
            let simulate = previousState && !previousState.position.equals(entity.position);
            stateInfo.push(currentState);
            //this is so it only stores current movement pos, and last movement pos.
            if (stateInfo.length > 2) {
                stateInfo.shift();
                // const simVel = simState.velocity.clone();
                simState.merge(stateInfo[0]);
                const simVel = entity.position.minus(simState.position);
                simState.velocity = simVel;
                // simState.velocity = simVel;
                if (simulate) {
                    console.log("TEST\n===========================", "\ndelta pos:", entity.position.minus(simState.position), '\nstate\'s vel:', simState.velocity, '\nstate\'s position:', simState.position, '\nwanted position:', entity.position);
                    const moves = yield this.moveSims.findCorrectMovements(simState, this.bot.world, entity.position);
                    simState.controlState = moves;
                    this.physics.simulatePlayer(simState, this.bot.world);
                    this.simStates[entity.id].mu = true;
                }
                // const moves = await this.moveSims.findCorrectMovements(simState, this.bot.world, entity.position);
                // simState.controlState = moves;
                // this.simStates[entityId].vu = false;
            }
        });
        this.physics = new physics_1.Physics((0, prismarine_registry_1.default)(bot.version));
        this.moveSims = new nextSim_1.MovementSimulations(this.bot, this.physics);
        // this.bot.on("physicsTick", () =>{
        //     this.tick++
        //     console.log("ticked", this.tick, this.bot.nearestEntity(e => e.username === "Generel_Schwerz")?.position, "Generel_Schwerz")
        // })
        // this.bot.on("entityMoved", (entity) => {
        //     console.log("moved.", this.tick, entity.position, entity.username)
        // })
        this.bot.on("entityMoved", this.updateStateInfo);
        this.bot._client.on("entity_velocity", this.perVelocityUpdateState);
    }
    getCorrectMovement(entity) {
        const simState = this.simStates[entity.id];
        if (!simState || !simState.mu || !simState.vu) {
            // console.log(!!simState, simState.mu, simState.vu)
            return null;
        }
        // console.log(simState.state.velocity)
        return simState.state.controlState;
    }
    trackEntity(entity) {
        var _a, _b;
        var _c, _d, _e, _f;
        if (this.trackingData[entity.id])
            this.trackingData[entity.id].tracking = true;
        (_a = (_c = this.trackingData)[_d = entity.id]) !== null && _a !== void 0 ? _a : (_c[_d] = { tracking: true, states: [] });
        (_b = (_e = this.simStates)[_f = entity.id]) !== null && _b !== void 0 ? _b : (_e[_f] = { mu: false, vu: false, state: entityState_1.EntityState.CREATE_FROM_ENTITY(this.physics, entity) });
    }
    stopTrackingEntity(entity, clear = false) {
        if (!this.trackingData[entity.id])
            return;
        this.trackingData[entity.id].tracking = false;
        if (clear) {
            delete this.trackingData[entity.id];
            delete this.simStates[entity.id];
        }
    }
    getTestState(entity) {
        return this.trackingData[entity.id] ? this.trackingData[entity.id].states[1] : null;
    }
    getEntityVelocity(entity) {
        return this.trackingData[entity.id] ? this.trackingData[entity.id].states[1].velocity : null;
    }
}
exports.MovementReader = MovementReader;
