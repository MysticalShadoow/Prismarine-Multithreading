"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovementSimulations = void 0;
const playerControls_1 = require("../player/playerControls");
const entityState_1 = require("../states/entityState");
const BasicMoves = [
    playerControls_1.ControlStateHandler.DEFAULT(),
    playerControls_1.ControlStateHandler.DEFAULT().set("forward", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("forward", true).set("right", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("forward", true).set("left", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("back", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("back", true).set("left", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("back", true).set("right", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("left", true),
    playerControls_1.ControlStateHandler.DEFAULT().set("right", true),
];
/**
 * To be used once per movement.
 *
 * Provide state that will serve as a base. The state itself will not be modified/consumed unless called for.
 */
class MovementSimulations {
    constructor(bot, ctx) {
        this.bot = bot;
        this.ctx = ctx;
    }
    *predictGenerator(state, world, ticks = 1, controls) {
        state.controlState = controls !== null && controls !== void 0 ? controls : playerControls_1.ControlStateHandler.DEFAULT();
        for (let current = 0; current < ticks; current++) {
            yield this.ctx.simulatePlayer(state, world);
        }
        return state;
    }
    predictForward(target, world, ticks = 1, controls) {
        const state = entityState_1.EntityState.CREATE_FROM_ENTITY(this.ctx, target);
        state.controlState = controls !== null && controls !== void 0 ? controls : playerControls_1.ControlStateHandler.DEFAULT();
        for (let current = 0; current < ticks; current++) {
            this.ctx.simulatePlayer(state, world);
        }
        return state;
    }
    findCorrectMovements(lastState, world, wantedPos) {
        // console.log("TEST\n===========================\ndelta pos:",wantedPos.minus(lastState.position), '\nstate\'s vel:', lastState.velocity, '\nstate\'s position:', lastState.position, '\nwanted position:', wantedPos)
        const defaultState = lastState.clone();
        const destinations = [];
        for (const move of BasicMoves) {
            const testState = defaultState.clone();
            testState.controlState = move.clone();
            this.ctx.simulatePlayer(testState, world);
            destinations.push([testState.position, testState.controlState]);
        }
        const flag = !defaultState.isUsingItem;
        const flag2 = defaultState.onGround || defaultState.isInWater || defaultState.isInLava;
        const flag3 = flag && flag2;
        // Apply sprint tests.
        // Only apply if moving forward AND not sneaking AND state not using item.
        if (flag) {
            for (const move of BasicMoves.filter(ctrl => ctrl.forward === true && ctrl.sneak === false && ctrl.back === false)) {
                const testState = defaultState.clone();
                testState.controlState = move.clone().set("sprint", true);
                this.ctx.simulatePlayer(testState, world);
                destinations.push([testState.position, testState.controlState]);
            }
        }
        // Apply jump, sneak, and jump-sneak tests.
        // Only test this if jump is relevant. Otherwise, ignore.
        if (flag2) {
            for (const move of BasicMoves) {
                const testState = defaultState.clone();
                testState.controlState = move.clone().set("jump", true);
                this.ctx.simulatePlayer(testState, world);
                destinations.push([testState.position, testState.controlState]);
            }
            for (const move of BasicMoves) {
                const testState1 = defaultState.clone();
                testState1.controlState = move.clone().set("sneak", true);
                this.ctx.simulatePlayer(testState1, world);
                destinations.push([testState1.position, testState1.controlState]);
            }
            for (const move of BasicMoves) {
                const testState2 = defaultState.clone();
                testState2.controlState = move.clone().set("jump", true).set("sneak", true);
                this.ctx.simulatePlayer(testState2, world);
                destinations.push([testState2.position, testState2.controlState]);
            }
        }
        // Apply sprint-jump tests.
        // Only apply if entity is on the ground, NOT shifting, and NOT holding backward.
        if (flag3) {
            for (const move of BasicMoves.filter(ctrl => ctrl.forward === true && ctrl.sneak === false && ctrl.back === false)) {
                const testState = defaultState.clone();
                testState.controlState = move.clone().set("sprint", true).set("jump", true);
                this.ctx.simulatePlayer(testState, world);
                destinations.push([testState.position, testState.controlState]);
            }
        }
        const closestControls = destinations.sort((a, b) => a[0].distanceTo(wantedPos) - b[0].distanceTo(wantedPos));
        return closestControls[0][1];
    }
}
exports.MovementSimulations = MovementSimulations;
