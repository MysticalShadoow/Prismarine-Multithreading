"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerState = exports.EntityDimensions = void 0;
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const nbt = __importStar(require("prismarine-nbt"));
const physicsUtils_1 = require("../extras/physicsUtils");
const playerControls_1 = require("../player/playerControls");
const defaultMoves = playerControls_1.ControlStateHandler.DEFAULT();
//Utility class that wraps PlayerPoses.
class EntityDimensions {
    constructor(width, height, fixed) {
        this.width = width;
        this.height = height;
        this.fixed = fixed;
    }
    static scalable(f, f2) {
        return new EntityDimensions(f, f2, false);
    }
    static fixed(f, f2) {
        return new EntityDimensions(f, f2, true);
    }
    makeBoundingBox(vec3) {
        return this.makeBoundingBoxCoords(vec3.x, vec3.y, vec3.z);
    }
    makeBoundingBoxCoords(d, d2, d3) {
        const f = this.width / 2.0;
        const f2 = this.height;
        return new mineflayer_util_plugin_1.AABB(d - f, d2, d3 - f, d + f, d2 + f2, d3 + f);
    }
    scale(f) {
        return this.scaleRaw(f, f);
    }
    scaleRaw(f, f2) {
        if (this.fixed || (f == 1.0 && f2 == 1.0)) {
            return this;
        }
        return EntityDimensions.scalable(this.width * f, this.height * f2);
    }
    toString() {
        return "EntityDimensions w=" + this.width + ", h=" + this.height + ", fixed=" + this.fixed;
    }
}
exports.EntityDimensions = EntityDimensions;
/**
 * Looking at this code, it's too specified towards players.
 *
 * I will eventually split this code into PlayerState and bot.entityState, where bot.entityState contains fewer controls.
 */
class PlayerState {
    constructor(ctx, bot, control) {
        var _a, _b, _c, _d;
        this.supportFeature = (0, physicsUtils_1.makeSupportFeature)(ctx.data);
        this.ctx = ctx;
        this.bot = bot;
        this.position = bot.entity.position.clone();
        this.velocity = bot.entity.velocity.clone();
        this.onGround = bot.entity.onGround;
        this.isInWater = bot.entity.isInWater;
        this.isInLava = bot.entity.isInLava;
        this.isInWeb = bot.entity.isInWeb;
        this.isCollidedHorizontally = bot.entity.isCollidedHorizontally;
        this.isCollidedVertically = bot.entity.isCollidedVertically;
        this.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        this.jumpTicks = (_a = bot.jumpTicks) !== null && _a !== void 0 ? _a : 0;
        this.jumpQueued = (_b = bot.jumpQueued) !== null && _b !== void 0 ? _b : false;
        // Input only (not modified)
        this.attributes = bot.entity.attributes;
        this.yaw = bot.entity.yaw;
        this.pitch = bot.entity.pitch;
        this.controlState = control !== null && control !== void 0 ? control : playerControls_1.ControlStateHandler.DEFAULT();
        this.isUsingItem = (0, physicsUtils_1.isEntityUsingItem)(bot.entity);
        this.isUsingMainHand = !(0, physicsUtils_1.whichHandIsEntityUsingBoolean)(bot.entity) && this.isUsingItem;
        this.isUsingOffHand = (0, physicsUtils_1.whichHandIsEntityUsingBoolean)(bot.entity) && this.isUsingItem;
        // effects
        this.effects = bot.entity.effects;
        this.statusEffectNames = (0, physicsUtils_1.getStatusEffectNamesForVersion)(this.supportFeature);
        this.jumpBoost = ctx.getEffectLevel(this.statusEffectNames.jumpBoostEffectName, this.effects);
        this.speed = ctx.getEffectLevel(this.statusEffectNames.speedEffectName, this.effects);
        this.slowness = ctx.getEffectLevel(this.statusEffectNames.slownessEffectName, this.effects);
        this.dolphinsGrace = ctx.getEffectLevel(this.statusEffectNames.dolphinsGraceEffectName, this.effects);
        this.slowFalling = ctx.getEffectLevel(this.statusEffectNames.slowFallingEffectName, this.effects);
        this.levitation = ctx.getEffectLevel(this.statusEffectNames.levitationEffectName, this.effects);
        // armour enchantments
        //const boots = bot.inventory.slots[8];
        const boots = bot.entity.equipment[5];
        if (boots && boots.nbt) {
            const simplifiedNbt = nbt.simplify(boots.nbt);
            const enchantments = (_d = (_c = simplifiedNbt.Enchantments) !== null && _c !== void 0 ? _c : simplifiedNbt.ench) !== null && _d !== void 0 ? _d : [];
            this.depthStrider = ctx.getEnchantmentLevel("depth_strider", enchantments);
        }
        else {
            this.depthStrider = 0;
        }
    }
    update(bot, control) {
        var _a, _b, _c, _d;
        // const bot.entity = bot instanceof bot.entity ? bot : bot.entity;
        // Input / Outputs
        this.position = bot.entity.position.clone();
        this.velocity = bot.entity.velocity.clone();
        this.onGround = bot.entity.onGround;
        this.isInWater = bot.entity.isInWater;
        this.isInLava = bot.entity.isInLava;
        this.isInWeb = bot.entity.isInWeb;
        this.isCollidedHorizontally = bot.entity.isCollidedHorizontally;
        this.isCollidedVertically = bot.entity.isCollidedVertically;
        // dunno what to do about these, ngl.
        this.jumpTicks = (_a = bot.jumpTicks) !== null && _a !== void 0 ? _a : 0;
        this.jumpQueued = (_b = bot.jumpQueued) !== null && _b !== void 0 ? _b : false;
        // Input only (not modified)
        this.attributes = bot.entity.attributes;
        this.yaw = bot.entity.yaw;
        this.pitch = bot.entity.pitch;
        this.controlState = control !== null && control !== void 0 ? control : this.controlState;
        this.isUsingItem = (0, physicsUtils_1.isEntityUsingItem)(bot.entity);
        this.isUsingMainHand = !(0, physicsUtils_1.whichHandIsEntityUsingBoolean)(bot.entity) && this.isUsingItem;
        this.isUsingOffHand = (0, physicsUtils_1.whichHandIsEntityUsingBoolean)(bot.entity) && this.isUsingItem;
        // effects
        this.effects = bot.entity.effects;
        this.jumpBoost = this.ctx.getEffectLevel(this.statusEffectNames.jumpBoostEffectName, this.effects);
        this.speed = this.ctx.getEffectLevel(this.statusEffectNames.speedEffectName, this.effects);
        this.slowness = this.ctx.getEffectLevel(this.statusEffectNames.slownessEffectName, this.effects);
        this.dolphinsGrace = this.ctx.getEffectLevel(this.statusEffectNames.dolphinsGraceEffectName, this.effects);
        this.slowFalling = this.ctx.getEffectLevel(this.statusEffectNames.slowFallingEffectName, this.effects);
        this.levitation = this.ctx.getEffectLevel(this.statusEffectNames.levitationEffectName, this.effects);
        // armour enchantments
        //const boots = bot.inventory.slots[8];
        const boots = bot.entity.equipment[5];
        if (boots && boots.nbt) {
            const simplifiedNbt = nbt.simplify(boots.nbt);
            const enchantments = (_d = (_c = simplifiedNbt.Enchantments) !== null && _c !== void 0 ? _c : simplifiedNbt.ench) !== null && _d !== void 0 ? _d : [];
            this.depthStrider = this.ctx.getEnchantmentLevel("depth_strider", enchantments);
        }
        else {
            this.depthStrider = 0;
        }
        return this;
    }
    apply(bot) {
        // const bot.entity = bot instanceof bot.entity ? bot : bot.entity;
        bot.entity.position = this.position;
        bot.entity.velocity = this.velocity;
        bot.entity.onGround = this.onGround;
        bot.entity.isInWater = this.isInWater;
        bot.entity.isInLava = this.isInLava;
        bot.entity.isInWeb = this.isInWeb;
        bot.entity.isCollidedHorizontally = this.isCollidedHorizontally;
        bot.entity.isCollidedVertically = this.isCollidedVertically;
        // dunno what to do about these, ngl.
        bot.jumpTicks = this.jumpTicks;
        bot.jumpQueued = this.jumpQueued;
        bot.entity.yaw = this.yaw;
        bot.entity.pitch = this.pitch;
        bot.controlState = this.controlState;
    }
    clone() {
        var _a, _b;
        const tmp = new PlayerState(this.ctx, this.bot, this.controlState);
        tmp.position = this.position.clone();
        tmp.velocity = this.velocity.clone();
        tmp.onGround = this.onGround;
        tmp.isInWater = this.isInWater;
        tmp.isInLava = this.isInLava;
        tmp.isInWeb = this.isInWeb;
        tmp.isCollidedHorizontally = this.isCollidedHorizontally;
        tmp.isCollidedVertically = this.isCollidedVertically;
        tmp.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        tmp.jumpTicks = (_a = this.jumpTicks) !== null && _a !== void 0 ? _a : 0;
        tmp.jumpQueued = (_b = this.jumpQueued) !== null && _b !== void 0 ? _b : false;
        // Input only (not modified)
        tmp.attributes = this.attributes;
        tmp.yaw = this.yaw;
        tmp.pitch = this.pitch;
        tmp.controlState = this.controlState;
        tmp.isUsingItem = this.isUsingItem;
        tmp.isUsingMainHand = this.isUsingMainHand;
        tmp.isUsingOffHand = this.isUsingOffHand;
        // effects
        tmp.effects = this.effects;
        tmp.statusEffectNames = this.statusEffectNames;
        tmp.jumpBoost = this.jumpBoost;
        tmp.speed = this.speed;
        tmp.slowness = this.slowness;
        tmp.dolphinsGrace = this.dolphinsGrace;
        tmp.slowFalling = this.slowFalling;
        tmp.levitation = this.levitation;
        tmp.depthStrider = this.depthStrider;
        return tmp;
    }
    merge(other) {
        var _a, _b;
        this.position = other.position.clone();
        this.velocity = other.velocity.clone();
        this.onGround = other.onGround;
        this.isInWater = other.isInWater;
        this.isInLava = other.isInLava;
        this.isInWeb = other.isInWeb;
        this.isCollidedHorizontally = other.isCollidedHorizontally;
        this.isCollidedVertically = other.isCollidedVertically;
        this.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        this.jumpTicks = (_a = other.jumpTicks) !== null && _a !== void 0 ? _a : 0;
        this.jumpQueued = (_b = other.jumpQueued) !== null && _b !== void 0 ? _b : false;
        // Input only (not modified)
        this.attributes = other.attributes;
        this.yaw = other.yaw;
        this.pitch = other.pitch;
        this.controlState = other.controlState.clone();
        this.isUsingItem = other.isUsingItem;
        this.isUsingMainHand = other.isUsingMainHand;
        this.isUsingOffHand = other.isUsingOffHand;
        // effects
        this.effects = other.effects;
        this.statusEffectNames = other.statusEffectNames;
        this.jumpBoost = other.jumpBoost;
        this.speed = other.speed;
        this.slowness = other.slowness;
        this.dolphinsGrace = other.dolphinsGrace;
        this.slowFalling = other.slowFalling;
        this.levitation = other.levitation;
        this.depthStrider = other.depthStrider;
        return this;
    }
    clearControlStates() {
        this.controlState = defaultMoves;
        return this;
        // console.log("hi", this.controlState)
        // for (const key in this.controlState) {
        //     this.controlState[key as ControlState] = false;
        //     console.log(this.controlState[key as ControlState])
        // }
    }
    getAABB() {
        const w = this.ctx.settings.playerHalfWidth;
        return new mineflayer_util_plugin_1.AABB(this.position.x - w, this.position.y, this.position.z - w, this.position.x + w, this.position.y + this.ctx.settings.playerHeight, this.position.z + w);
    }
    getUnderlyingBlockBBs(world /*prismarine-world*/) {
        const queryBB = this.getAABB();
        return this.ctx.getUnderlyingBlockBBs(queryBB, world);
    }
    getSurroundingBBs(world /*prismarine-world*/) {
        const queryBB = this.getAABB();
        return this.ctx.getSurroundingBBs(queryBB, world);
    }
}
exports.PlayerState = PlayerState;
