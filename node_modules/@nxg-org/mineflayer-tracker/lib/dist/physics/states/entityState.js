"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityState = void 0;
const vec3_1 = require("vec3");
const physics_1 = require("../engines/physics");
const playerControls_1 = require("../player/playerControls");
const poses_1 = require("./poses");
const physicsUtils_1 = require("../extras/physicsUtils");
const prismarine_nbt_1 = __importDefault(require("prismarine-nbt"));
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const emptyVec = new vec3_1.Vec3(0, 0, 0);
class EntityState {
    // public effects: Effect[];
    // public statusEffectNames;
    constructor(ctx, position, velocity, onGround, controlState, yaw, pitch) {
        this.ctx = ctx;
        this.position = position;
        this.velocity = velocity;
        this.onGround = onGround;
        this.controlState = controlState;
        this.yaw = yaw;
        this.pitch = pitch;
        this.isInWater = false;
        this.isInLava = false;
        this.isInWeb = false;
        this.isCollidedHorizontally = false;
        this.isCollidedVertically = false;
        this.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        this.jumpTicks = 0;
        this.jumpQueued = false;
        // Input only (not modified)
        this.attributes = {}; //TODO
        this.isUsingItem = false;
        this.isUsingMainHand = false;
        this.isUsingOffHand = false;
        // effects
        this.effects = [];
        this.jumpBoost = 0;
        this.speed = 0;
        this.slowness = 0;
        this.dolphinsGrace = 0;
        this.slowFalling = 0;
        this.levitation = 0;
        this.depthStrider = 0;
        this.pose = poses_1.PlayerPoses.STANDING;
    }
    static CREATE_FROM_BOT(ctx, bot) {
        return new EntityState(ctx, bot.entity.position.clone(), bot.entity.velocity.clone(), bot.entity.onGround, playerControls_1.ControlStateHandler.COPY_BOT(bot), bot.entity.yaw, bot.entity.pitch).updateFromBot(bot);
    }
    static CREATE_FROM_ENTITY(ctx, entity) {
        return new EntityState(ctx, entity.position.clone(), entity.velocity.clone(), entity.onGround, playerControls_1.ControlStateHandler.DEFAULT(), entity.yaw, entity.pitch).updateFromEntity(entity);
    }
    static CREATE_FROM_PLAYER_STATE(ctx, state) {
        return new EntityState(ctx, state.position.clone(), state.velocity.clone(), state.onGround, state.controlState.clone(), state.yaw, state.pitch).updateFromRaw(state);
    }
    /**
     * Slightly different from the other two, use a pre-built object (assuming cloned) material.
     * @param ctx Physics instance.
     * @param raw CONSUMEABLE, build this with clones.
     * @returns PhysicsState
     */
    static CREATE_RAW(ctx, raw) {
        return new EntityState(ctx, raw.position, raw.velocity, raw.onGround, raw.controlState, raw.yaw, raw.pitch);
    }
    updateFromBot(bot) {
        var _a, _b;
        this.controlState = playerControls_1.ControlStateHandler.COPY_BOT(bot);
        this.onGround = this.onGround;
        this.isUsingItem = (0, physicsUtils_1.isEntityUsingItem)(bot.entity);
        this.attributes = bot.entity.attributes;
        this.effects = bot.entity.effects;
        this.jumpBoost = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.JUMP_BOOST, bot.entity.effects);
        this.speed = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SPEED, this.effects);
        this.slowness = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SLOWNESS, this.effects);
        this.dolphinsGrace = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.DOLPHINS_GRACE, this.effects);
        this.slowFalling = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SLOW_FALLING, this.effects);
        this.levitation = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.LEVITATION, this.effects);
        const boots = bot.entity.equipment[5];
        if (boots && boots.nbt) {
            const simplifiedNbt = prismarine_nbt_1.default.simplify(boots.nbt);
            const enchantments = (_b = (_a = simplifiedNbt.Enchantments) !== null && _a !== void 0 ? _a : simplifiedNbt.ench) !== null && _b !== void 0 ? _b : [];
            this.depthStrider = this.ctx.getEnchantmentLevelCustom(physics_1.CheapEnchantments.DEPTH_STRIDER, enchantments);
        }
        else {
            this.depthStrider = 0;
        }
        return this;
    }
    updateFromEntity(entity) {
        var _a, _b;
        this.position = entity.position.clone();
        this.velocity = entity.velocity.clone();
        this.onGround = entity.onGround;
        this.isInWater = entity.isInWater;
        this.isInLava = entity.isInLava;
        this.isInWeb = entity.isInWeb;
        this.isCollidedHorizontally = entity.isCollidedHorizontally;
        this.isCollidedVertically = entity.isCollidedVertically;
        this.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        this.jumpTicks = 0;
        this.jumpQueued = false;
        // Input only (not modified)
        this.attributes = entity.attributes;
        this.yaw = entity.yaw;
        this.pitch = entity.pitch;
        this.controlState = playerControls_1.ControlStateHandler.DEFAULT();
        this.isUsingItem = (0, physicsUtils_1.isEntityUsingItem)(entity);
        this.isUsingMainHand = !(0, physicsUtils_1.whichHandIsEntityUsingBoolean)(entity) && this.isUsingItem;
        this.isUsingOffHand = (0, physicsUtils_1.whichHandIsEntityUsingBoolean)(entity) && this.isUsingItem;
        // effects
        this.effects = entity.effects;
        this.jumpBoost = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.JUMP_BOOST, this.effects);
        this.speed = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SPEED, this.effects);
        this.slowness = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SLOWNESS, this.effects);
        this.dolphinsGrace = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.DOLPHINS_GRACE, this.effects);
        this.slowFalling = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.SLOW_FALLING, this.effects);
        this.levitation = this.ctx.getEffectLevelCustom(physics_1.CheapEffects.LEVITATION, this.effects);
        // armour enchantments
        //const boots = bot.inventory.slots[8];
        const boots = entity.equipment[5];
        if (boots && boots.nbt) {
            const simplifiedNbt = prismarine_nbt_1.default.simplify(boots.nbt);
            const enchantments = (_b = (_a = simplifiedNbt.Enchantments) !== null && _a !== void 0 ? _a : simplifiedNbt.ench) !== null && _b !== void 0 ? _b : [];
            this.depthStrider = this.ctx.getEnchantmentLevel("depth_strider", enchantments);
        }
        else {
            this.depthStrider = 0;
        }
        this.pose = poses_1.PlayerPoses.STANDING;
        return this;
    }
    updateFromRaw(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        this.onGround = (_a = other.onGround) !== null && _a !== void 0 ? _a : this.onGround;
        this.sneakCollision = (_b = other.sneakCollision) !== null && _b !== void 0 ? _b : this.sneakCollision;
        this.isUsingItem = (_c = other.isUsingItem) !== null && _c !== void 0 ? _c : this.isUsingItem;
        this.jumpBoost = (_d = other.jumpBoost) !== null && _d !== void 0 ? _d : this.jumpBoost;
        this.speed = (_e = other.speed) !== null && _e !== void 0 ? _e : this.speed;
        this.slowness = (_f = other.slowness) !== null && _f !== void 0 ? _f : this.slowness;
        this.dolphinsGrace = (_g = other.dolphinsGrace) !== null && _g !== void 0 ? _g : this.dolphinsGrace;
        this.slowFalling = (_h = other.slowFalling) !== null && _h !== void 0 ? _h : this.slowFalling;
        this.levitation = (_j = other.levitation) !== null && _j !== void 0 ? _j : this.levitation;
        this.depthStrider = (_k = other.depthStrider) !== null && _k !== void 0 ? _k : this.depthStrider;
        this.effects = (_l = other.effects) !== null && _l !== void 0 ? _l : this.effects;
        return this;
    }
    applyToBot(bot) {
        bot.entity.position = this.position;
        bot.entity.velocity = this.velocity;
        bot.entity.onGround = this.onGround;
        bot.entity.yaw = this.yaw;
        bot.entity.pitch = this.pitch;
        bot.controlState = this.controlState;
        return this;
    }
    /**
     * No idea when you'd use this.
     */
    applyToEntity(entity) {
        entity.position = this.position;
        entity.velocity = this.velocity;
        entity.onGround = this.onGround;
        entity.yaw = this.yaw;
        entity.pitch = this.pitch;
        return this;
    }
    clone() {
        const other = new EntityState(this.ctx, this.position.clone(), this.velocity.clone(), this.onGround, this.controlState.clone(), this.yaw, this.pitch);
        other.isCollidedHorizontally = this.isCollidedHorizontally;
        other.isCollidedVertically = this.isCollidedVertically;
        other.isInWater = this.isInWater;
        other.isInLava = this.isInLava;
        other.isInWeb = this.isInWeb;
        other.jumpTicks = this.jumpTicks;
        other.jumpQueued = this.jumpQueued;
        other.sneakCollision = this.sneakCollision;
        other.attributes = this.attributes;
        other.isUsingItem = this.isUsingItem;
        other.isUsingMainHand = this.isUsingMainHand;
        other.isUsingOffHand = this.isUsingOffHand;
        other.jumpBoost = this.jumpBoost;
        other.speed = this.speed;
        other.slowness = this.slowness;
        other.dolphinsGrace = this.dolphinsGrace;
        other.slowFalling = this.slowFalling;
        other.levitation = this.levitation;
        other.depthStrider = this.depthStrider;
        other.effects = this.effects;
        other.pose = this.pose;
        return other;
    }
    merge(other) {
        this.position = other.position.clone();
        this.velocity = other.velocity.clone();
        this.onGround = other.onGround;
        this.isCollidedHorizontally = other.isCollidedHorizontally;
        this.isCollidedVertically = other.isCollidedVertically;
        this.isInWater = other.isInWater;
        this.isInLava = other.isInLava;
        this.isInWeb = other.isInWeb;
        this.jumpTicks = other.jumpTicks;
        this.jumpQueued = other.jumpQueued;
        this.sneakCollision = other.sneakCollision;
        this.attributes = other.attributes;
        this.isUsingItem = other.isUsingItem;
        this.isUsingMainHand = other.isUsingMainHand;
        this.isUsingOffHand = other.isUsingOffHand;
        this.jumpBoost = other.jumpBoost;
        this.speed = other.speed;
        this.slowness = other.slowness;
        this.dolphinsGrace = other.dolphinsGrace;
        this.slowFalling = other.slowFalling;
        this.levitation = other.levitation;
        this.depthStrider = other.depthStrider;
        this.effects = other.effects;
        this.pose = other.pose;
        return this;
    }
    clearControlStates() {
        this.controlState = playerControls_1.ControlStateHandler.DEFAULT();
        return this;
    }
    /**
     * needs to be updated.
     * @returns AABB
     */
    getAABB() {
        const w = this.ctx.settings.playerHalfWidth;
        return new mineflayer_util_plugin_1.AABB(this.position.x - w, this.position.y, this.position.z - w, this.position.x + w, this.position.y + this.ctx.settings.playerHeight, this.position.z + w);
    }
    getUnderlyingBlockBBs(world /*prismarine-world*/) {
        const queryBB = this.getAABB();
        return this.ctx.getUnderlyingBlockBBs(queryBB, world);
    }
    getSurroundingBBs(world /*prismarine-world*/) {
        const queryBB = this.getAABB();
        return this.ctx.getSurroundingBBs(queryBB, world);
    }
}
exports.EntityState = EntityState;
