"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonSense = exports.DefaultCommonSenseOptions = void 0;
const vec3_1 = require("vec3");
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const { Physics, PlayerState } = require("prismarine-physics");
const levenshtein = require("js-levenshtein");
const sleep = (ms) => new Promise((res, rej) => setTimeout(res, ms));
exports.DefaultCommonSenseOptions = {
    autoRespond: false,
    mlgCheck: false,
    mlgMountFirst: false,
    fireCheck: false,
    useOffhand: false,
    reach: 4,
    mlgItems: [
        { name: "water_bucket", disallowedDimensons: ["nether"] },
        { name: "boat", maxDistance: 30 },
        { name: "sweet_berries", allowedBlocks: ["grass"] },
        { name: "slime_block" },
        { name: "hay_block" },
    ],
    mlgVehicles: ["horse", "boat", "donkey", "mule", "minecart"],
    strictMlgNameMatch: false,
    strictMlgBlockMatch: false,
};
class CommonSense {
    constructor(bot, options) {
        this.bot = bot;
        this.isFalling = false;
        this.isOnFire = false;
        this.requipLastItem = false;
        this.puttingOutFire = false;
        this.MLGing = false;
        this.isFallingCheckEasy = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.options.mlgCheck)
                return;
            if (this.bot.entity.velocity.y >= -0.6 || this.bot.entity.isInWater) {
                this.isFalling = false;
                return;
            }
            this.isFalling = true;
            if (!this.MLGing && this.options.autoRespond && this.isFalling) {
                if (this.options.mlgCheck instanceof Object) {
                    this.options.mlgCheck.mountOnly ? yield this.entityMountMLG() : this.placementMLG();
                }
                else {
                    yield this.placementMLG();
                }
            }
        });
        this.onMetadataFireCheck = (packet) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.options.fireCheck)
                return;
            if (!packet.entityId)
                return;
            const entity = this.bot.entities[packet.entityId];
            if (!entity || entity !== this.bot.entity)
                return;
            const wantedKey = packet.metadata.findIndex((md) => md.key === 0);
            if (wantedKey === -1)
                return;
            if (((_a = packet.metadata[wantedKey]) === null || _a === void 0 ? void 0 : _a.value) !== 0x01) {
                this.isOnFire = false;
                return;
            }
            this.isOnFire = true;
            if (!this.options.autoRespond)
                return;
            if (this.bot.game.dimension.includes("nether"))
                return; // don't handle fire here.
            while (!this.bot.entity.onGround || this.MLGing)
                yield this.bot.waitForTicks(1);
            if (!this.puttingOutFire && this.isOnFire && !this.bot.entity.isInWater)
                this.putOutFire();
        });
        this.onStatusFireCheck = (packet) => __awaiter(this, void 0, void 0, function* () {
            if (!this.options.fireCheck)
                return;
            if (!packet.entityId)
                return;
            const entity = this.bot.entities[packet.entityId];
            if (!entity || entity !== this.bot.entity)
                return;
            if (!packet.entityStatus || packet.entityStatus !== 37) {
                this.isOnFire = false;
                return;
            }
            this.isOnFire = true;
            if (!this.options.autoRespond)
                return;
            if (this.bot.game.dimension.includes("nether"))
                return; // don't handle fire here.
            while (!this.bot.entity.onGround || this.MLGing)
                yield this.bot.waitForTicks(1);
            if (!this.puttingOutFire && this.isOnFire && !this.bot.entity.isInWater)
                this.putOutFire();
        });
        this.mountEntityFilter = (e) => {
            const namecheck = this.options.mlgVehicles.some((name) => { var _a; return (_a = e.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(name.toLowerCase()); });
            const distCheck = e.position.distanceTo(this.bot.entity.position) < this.options.reach;
            return namecheck && distCheck;
        };
        this.options = Object.assign(exports.DefaultCommonSenseOptions, options);
        this.blocksByName = bot.registry.blocksByName;
        this.bot.on("physicsTick", this.isFallingCheckEasy);
        this.bot._client.on("entity_metadata", this.onMetadataFireCheck);
        this.bot._client.on("entity_status", this.onStatusFireCheck);
        this.bot.on("death", () => {
            this.MLGing = false;
            this.isFalling = false;
        });
        this.causesFire = new Set();
        this.causesFire.add(this.blocksByName.lava.id);
        this.causesFire.add(this.blocksByName.fire.id);
        if (!this.options.mlgVehicles.includes("boat"))
            this.options.mlgVehicles.push("boat");
    }
    setOptions(options) {
        Object.assign(this.options, options);
        return this.options;
    }
    putOutFire() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.puttingOutFire)
                return true;
            this.puttingOutFire = true;
            const hand = this.bot.util.inv.getHand(this.options.useOffhand);
            const water = this.bot.util.inv.getAllItemsExceptCurrent(hand).find((item) => item === null || item === void 0 ? void 0 : item.name.includes("water_bucket"));
            const holdingItem = (_a = this.bot.util.inv.getHandWithItem(this.options.useOffhand)) === null || _a === void 0 ? void 0 : _a.name.includes("water_bucket");
            if (!water && !holdingItem) {
                this.puttingOutFire = false;
                return false;
            }
            else if (!holdingItem && water) {
                yield this.bot.equip(water, hand);
            }
            if (!((_b = this.bot.util.inv.getHandWithItem(this.options.useOffhand)) === null || _b === void 0 ? void 0 : _b.name.includes("water_bucket"))) {
                this.puttingOutFire = false;
                return false;
            }
            const nearbyBlock = this.bot.findBlock({ matching: (block) => this.causesFire.has(block.type), maxDistance: 3 });
            if (nearbyBlock) {
                // solid block, meaning it must be fire.
                if (nearbyBlock.diggable)
                    yield this.bot.dig(nearbyBlock, true);
                yield this.bot.util.move.forceLookAt(nearbyBlock.position.offset(0.5, -1, 0.5));
            }
            else {
                const placeBlock = this.findMLGPlacementBlock();
                if (placeBlock) {
                    console.log("have placement block, looking there");
                    yield this.bot.util.move.forceLookAt(placeBlock.position.offset(0.5, 0.5, 0.5));
                }
                else {
                    yield this.bot.util.move.forceLookAt(this.bot.entity.position.offset(0, -1, 0));
                }
            }
            // while (!this.bot.entity.isCollidedVertically) await this.bot.waitForTicks(1);
            this.bot.activateItem(this.options.useOffhand);
            const checkPos = (_c = nearbyBlock === null || nearbyBlock === void 0 ? void 0 : nearbyBlock.position) !== null && _c !== void 0 ? _c : this.bot.entity.position;
            yield waitFor(this.bot, `blockUpdate`, {
                timeout: 500,
                listener: (old, nw) => nw.type === this.bot.registry.blocksByName.water.id && nw.position.xzDistanceTo(checkPos) < 3,
            });
            yield this.pickUpWater(nearbyBlock === null || nearbyBlock === void 0 ? void 0 : nearbyBlock.position, 5);
            this.puttingOutFire = false;
            return true;
        });
    }
    reachableFireCauserBlocks(maxDistance = this.options.reach) {
        const eyePos = this.bot.entity.position.offset(0, 1.62, 0);
        return this.bot.findBlocks({
            maxDistance: 8,
            // placed water will always be on top of wanted block.
            point: this.bot.entity.position,
            matching: (block) => this.causesFire.has(block.type) && mineflayer_util_plugin_1.AABBUtils.getBlockAABB(block).distanceToVec(eyePos) < maxDistance,
        });
    }
    findLocalWater(nearbyBlockPos = this.bot.entity.position, maxDistance = this.options.reach) {
        const eyePos = this.bot.entity.position.offset(0, 1.62, 0);
        return this.bot.findBlock({
            // placed water will always be on top of wanted block.
            maxDistance: 8,
            point: nearbyBlockPos,
            matching: (block) => {
                const waterSrcCheck = block.type === this.blocksByName.water.id && block.metadata === 0;
                const waterLoggedBlock = block._properties.waterlogged;
                const distCheck = mineflayer_util_plugin_1.AABBUtils.getBlockAABB(block).distanceToVec(eyePos) < maxDistance;
                return (waterSrcCheck || waterLoggedBlock) && distCheck;
            },
            useExtraInfo: true,
        });
    }
    findMLGPlacementBlock() {
        let pos;
        if (this.options.mlgCheck instanceof Object) {
            const playerState = new PlayerState(this.bot, this.bot.controlState);
            this.bot.physics.simulatePlayer(playerState, this.bot.world); // in place transition
            pos = playerState.pos;
        }
        else {
            pos = this.bot.entity.position;
        }
        const aabb = mineflayer_util_plugin_1.AABBUtils.getEntityAABBRaw({
            position: pos,
            height: this.bot.entity.height,
            width: 0.599, // we are avoiding colliding with adjacent blocks.
        });
        const floored = {
            x0: Math.floor(aabb.minX),
            z0: Math.floor(aabb.minZ),
            x1: Math.floor(aabb.maxX),
            z1: Math.floor(aabb.maxZ),
        };
        let blocks = [];
        const posY = Math.floor(this.bot.entity.position.y);
        const cursor = new vec3_1.Vec3(floored.x0, posY, floored.z0);
        for (cursor.x = floored.x0; cursor.x <= floored.x1; cursor.x++) {
            for (cursor.z = floored.z0; cursor.z <= floored.z1; cursor.z++) {
                loop3: for (cursor.y = posY; cursor.y >= this.bot.game.minY; cursor.y--) {
                    const block = this.bot.blockAt(cursor);
                    if (!block)
                        continue;
                    if (block.type !== this.blocksByName.water.id &&
                        block.type !== this.blocksByName.air.id &&
                        !block.transparent) {
                        blocks.push(block);
                        break loop3;
                    }
                }
            }
        }
        blocks = blocks.filter((b) => b.position.y < aabb.minY);
        const maxY = Math.max(...blocks.map((b) => b.position.y));
        blocks = blocks.filter((b) => b.position.y === maxY);
        const block = blocks.sort((a, b) => mineflayer_util_plugin_1.AABBUtils.getBlockAABB(a).distanceToVec(pos) - mineflayer_util_plugin_1.AABBUtils.getBlockAABB(b).distanceToVec(pos))[0];
        return block !== null && block !== void 0 ? block : null;
    }
    getMLGItem(orgHeight, landingBlock) {
        for (const mlgInfo of this.options.mlgItems) {
            if (mlgInfo.maxDistance !== undefined && mlgInfo.maxDistance < orgHeight - landingBlock.position.y)
                continue;
            // console.log(landingBlock, mlgInfo, mlgInfo.allowedBlocks?.some((name) => landingBlock.name.includes(name)));
            if (this.options.strictMlgBlockMatch && mlgInfo.allowedBlocks !== undefined) {
                if (!mlgInfo.allowedBlocks.some((name) => landingBlock.name === name))
                    continue;
            }
            else if (mlgInfo.allowedBlocks !== undefined) {
                if (!mlgInfo.allowedBlocks.some((name) => landingBlock.name.includes(name))) {
                    continue;
                }
            }
            if (mlgInfo.disallowedDimensons !== undefined) {
                if (mlgInfo.disallowedDimensons.some(name => this.bot.game.dimension.includes(name)))
                    continue;
            }
            if (this.options.strictMlgNameMatch) {
                const toEquip = this.bot.util.inv.getAllItems().find((item) => (item === null || item === void 0 ? void 0 : item.name) === mlgInfo.name);
                if (toEquip)
                    return toEquip;
            }
            else {
                const toEquip = this.bot.util.inv.getAllItems().find((item) => item === null || item === void 0 ? void 0 : item.name.includes(mlgInfo.name));
                if (toEquip)
                    return toEquip;
            }
        }
        return null;
    }
    entityMountMLG(override = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.MLGing && !override)
                return true;
            this.MLGing = true;
            for (let i = 0; i < 1000; i++) {
                const e = this.bot.nearestEntity(this.mountEntityFilter);
                if (e) {
                    this.bot.util.move.forceLookAt(mineflayer_util_plugin_1.AABBUtils.getEntityAABB(e).getCenter(), true);
                    if (["horse", "donkey", "mule"].some((name) => { var _a; return (_a = e.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(name); })) {
                        this.bot.unequip("hand");
                    }
                    this.bot.mount(e);
                    yield waitFor(this.bot, "mount");
                    this.bot.dismount();
                    break;
                }
                yield this.bot.waitForTicks(1);
            }
            this.MLGing = false;
            return true;
        });
    }
    // this logic does not work for spawn eggs.
    findMLGItemType(item) {
        let type = 1; // placeable block (placeBlock)
        if (item.stackSize === 1)
            type--; // 0 for single stack items (activateItem)
        if (["boat"].some((name) => item.name.includes(name)))
            type += 2; // 2 for entitySpawns (placeEntity)
        return type;
    }
    placementMLG() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.MLGing)
                return true;
            let landingBlock = this.findMLGPlacementBlock();
            if (!landingBlock)
                return false; // no blocks til void beneath us...
            const startHeight = this.bot.entity.position.y;
            let mlgItem = this.getMLGItem(startHeight, landingBlock);
            const heldItem = this.bot.util.inv.getHandWithItem(this.options.useOffhand);
            if (!mlgItem)
                return yield this.entityMountMLG(true);
            this.MLGing = true;
            const hand = this.bot.util.inv.getHand(this.options.useOffhand);
            for (let i = 0; i < 1000; i++) {
                if (((_a = this.bot.blockAt(this.bot.entity.position)) === null || _a === void 0 ? void 0 : _a.type) === this.blocksByName.water.id) {
                    this.MLGing = false;
                    return true;
                }
                landingBlock = this.findMLGPlacementBlock();
                if (!landingBlock)
                    return false; // no blocks til void beneath us...
                mlgItem = (_b = this.getMLGItem(startHeight, landingBlock)) !== null && _b !== void 0 ? _b : mlgItem;
                if ((heldItem === null || heldItem === void 0 ? void 0 : heldItem.name) !== mlgItem.name) {
                    yield this.bot.equip(mlgItem, hand);
                }
                if (this.bot.entity.position.y <= landingBlock.position.y + this.options.reach) {
                    this.bot.util.move.forceLookAt(landingBlock.position.offset(0.5, 1, 0.5), true);
                    if (landingBlock.type !== this.blocksByName.water.id)
                        break;
                }
                yield this.bot.waitForTicks(1);
            }
            switch (this.findMLGItemType(mlgItem)) {
                case 0:
                    this.bot.activateItem(this.options.useOffhand);
                    if (mlgItem.name === "water_bucket") {
                        yield waitFor(this.bot, `blockUpdate`, {
                            timeout: 500,
                            listener: (old, nw) => nw.type === this.bot.registry.blocksByName.water.id &&
                                nw.position.xzDistanceTo(this.bot.entity.position) < 2,
                        });
                        try {
                            yield this.waitForBBCollision(landingBlock.position, 500);
                        }
                        catch (_c) {
                            return false;
                        }
                        yield this.pickUpWater(landingBlock.position, 5);
                    }
                    break;
                case 1:
                    yield this.naivePlaceAndCheck(mlgItem, landingBlock, new vec3_1.Vec3(0, 1, 0), {
                        offhand: this.options.useOffhand,
                        swingArm: hand,
                    });
                    break;
                case 2:
                    if (!this.bot.nearestEntity(this.mountEntityFilter)) {
                        this.bot._placeEntityWithOptions(landingBlock, new vec3_1.Vec3(0, 1, 0), {
                            offhand: this.options.useOffhand,
                            swingArm: hand,
                        });
                    }
                    return yield this.entityMountMLG(true);
                // return this.entityMountMLG(true);
            }
            this.MLGing = false;
            return true;
        });
    }
    pickUpWater(pos = this.bot.entity.position, dist = this.options.reach) {
        var _a;
        const waterBlock = this.findLocalWater(pos, dist);
        if (waterBlock) {
            this.bot.util.move.forceLookAt(waterBlock.position.offset(0.5, 0.5, 0.5), true);
            if (((_a = this.bot.util.inv.getHandWithItem(this.bot.commonSense.options.useOffhand)) === null || _a === void 0 ? void 0 : _a.name) === "bucket")
                this.bot.activateItem(this.options.useOffhand);
        }
    }
    naivePlaceAndCheck(item, block, placeVector, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = block.position.plus(placeVector);
            let ret = false;
            // BAD way of checking correlation between item to place and block.
            // Ideally, we'd link every item to their placement counterpart.
            const listener = (oldBlock, newBlock) => {
                if ((oldBlock === null || oldBlock === void 0 ? void 0 : oldBlock.type) === newBlock.type) {
                    if (levenshtein(item.name, oldBlock.name) < 8) {
                        ret = true;
                    }
                }
                this.bot.off(`blockUpdate:${dest}`, listener);
            };
            this.bot.prependOnceListener(`blockUpdate:${dest}`, listener);
            try {
                yield this.bot._placeBlockWithOptions(block, placeVector, options);
                return true;
            }
            catch (e) {
                return ret;
            }
        });
    }
    waitForBBCollision(bPos, timeout = 500) {
        const bb = mineflayer_util_plugin_1.AABB.fromVecs(bPos, bPos.offset(1, 1, 1));
        return new Promise((res, rej) => {
            const listener = (pos) => {
                const bb1 = mineflayer_util_plugin_1.AABBUtils.getPlayerAABB(this.bot.entity);
                if (bb.collides(bb1)) {
                    this.bot.off("move", listener);
                    res();
                }
            };
            this.bot.on("move", listener);
            setTimeout(rej, timeout);
        });
    }
}
exports.CommonSense = CommonSense;
function waitFor(bot, event, options) {
    return new Promise((res, rej) => {
        const internal = (...args) => {
            if (!!(options === null || options === void 0 ? void 0 : options.listener)) {
                const ret = options.listener(...args);
                if (ret) {
                    bot.off(event, internal);
                    res(args);
                }
            }
            else {
                bot.off(event, internal);
                res(args);
            }
        };
        bot.on(event, internal);
        if (!!(options === null || options === void 0 ? void 0 : options.timeout)) {
            setTimeout(res, options.timeout);
        }
    });
}
