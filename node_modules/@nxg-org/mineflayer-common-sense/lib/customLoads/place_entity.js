"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inject = void 0;
const assert = require("assert");
function inject(bot) {
    const Item = require('prismarine-item')(bot.registry);
    /**
     *
     * @param {import('prismarine-block').Block} referenceBlock
     * @param {import('vec3').Vec3} faceVector
     * @param {{forceLook?: boolean | 'ignore', offhand?: boolean, swingArm?: 'right' | 'left', showHand?: boolean}} options
     */
    function placeEntityWithOptions(referenceBlock, faceVector, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const item = bot.util.inv.getHandWithItem(options.offhand);
            if (!item)
                throw new Error('must be holding an item to place an entity');
            const type = item.name // used for assert
                .replace(/.+_boat/, 'boat')
                .replace(/.+_spawn_egg/, 'spawn_egg');
            assert(['end_crystal', 'boat', 'spawn_egg', 'armor_stand'].includes(type), 'Unimplemented');
            let name = item.name // used for finding entity after spawn
                .replace(/.+_boat/, 'boat');
            if (name.endsWith('spawn_egg')) {
                name = item.spawnEggMobName;
            }
            if (type === 'spawn_egg') {
                options.showHand = false;
            }
            if (!options.swingArm)
                options.swingArm = options.offhand ? 'left' : 'right';
            const pos = yield bot._genericPlace(referenceBlock, faceVector, options);
            if (type === 'boat') {
                console.log(bot.supportFeature('useItemWithOwnPacket'), options.offhand);
                if (bot.supportFeature('useItemWithOwnPacket')) {
                    bot._client.write('use_item', {
                        hand: options.offhand ? 1 : 0
                    });
                }
                else {
                    bot._client.write('block_place', {
                        location: { x: -1, y: -1, z: -1 },
                        direction: -1,
                        heldItem: Item.toNotch(item),
                        cursorX: 0,
                        cursorY: 0,
                        cursorZ: 0
                    });
                }
            }
            const dest = pos.plus(faceVector);
            const entity = yield waitForEntitySpawn(name, dest);
            bot.emit('entityPlaced', entity);
            return entity;
        });
    }
    function placeEntity(referenceBlock, faceVector) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield placeEntityWithOptions(referenceBlock, faceVector, {});
        });
    }
    function waitForEntitySpawn(name, placePosition) {
        const maxDistance = name === 'bat' ? 4 : name === 'boat' ? 3 : 2;
        let mobName = name;
        if (name === 'end_crystal') {
            if (bot.supportFeature('enderCrystalNameEndsInErNoCaps')) {
                mobName = 'ender_crystal';
            }
            else if (bot.supportFeature('entityNameLowerCaseNoUnderscore')) {
                mobName = 'endercrystal';
            }
            else if (bot.supportFeature('enderCrystalNameNoCapsWithUnderscore')) {
                mobName = 'end_crystal';
            }
            else {
                mobName = 'EnderCrystal';
            }
        }
        else if (name === 'boat') {
            mobName = bot.supportFeature('entityNameUpperCaseNoUnderscore') ? 'Boat' : 'boat';
        }
        else if (name === 'armor_stand') {
            if (bot.supportFeature('entityNameUpperCaseNoUnderscore')) {
                mobName = 'ArmorStand';
            }
            else if (bot.supportFeature('entityNameLowerCaseNoUnderscore')) {
                mobName = 'armorstand';
            }
            else {
                mobName = 'armor_stand';
            }
        }
        return new Promise((resolve, reject) => {
            function listener(entity) {
                const dist = entity.position.distanceTo(placePosition);
                if (entity.name === mobName && dist < maxDistance) {
                    resolve(entity);
                }
                bot.off('entitySpawn', listener);
            }
            setTimeout(() => {
                bot.off('entitySpawn', listener);
                reject(new Error('Failed to place entity'));
            }, 5000); // reject after 5s
            bot.on('entitySpawn', listener);
        });
    }
    bot.placeEntity = placeEntity;
    bot._placeEntityWithOptions = placeEntityWithOptions;
}
exports.inject = inject;
