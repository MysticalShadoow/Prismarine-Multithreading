"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectileTracker = void 0;
const index_1 = require("./index");
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
class ProjectileTracker {
    constructor(bot) {
        this.bot = bot;
        this.intercepter = new mineflayer_util_plugin_1.InterceptFunctions(bot);
    }
    getIncomingArrow() {
        var _a;
        const arrowInfos = this.getIncomingArrows();
        return (_a = arrowInfos.sort((a, b) => a.info.totalTicks - b.info.totalTicks)[0]) !== null && _a !== void 0 ? _a : null;
    }
    getIncomingArrows() {
        const hittingArrows = [];
        const aabbComponents = { position: this.bot.entity.position, height: this.bot.entity.height + 0.18, width: 0.3 };
        for (const entity of Object.values(this.bot.entities).filter((e) => { var _a; return (_a = e.name) === null || _a === void 0 ? void 0 : _a.includes("arrow"); })) {
            const init = index_1.ShotFactory.fromEntity(entity, this.intercepter);
            const info = init.hitsEntity(aabbComponents);
            if (!!info)
                hittingArrows.push({ entity, info });
        }
        return hittingArrows;
    }
    getIncomingProjectiles() {
        const hittingArrows = [];
        const aabbComponents = { position: this.bot.entity.position, height: this.bot.entity.height + 0.18, width: 0.3 };
        const knownProjectiles = Object.keys(index_1.projectileGravity);
        for (const entity of Object.values(this.bot.entities).filter((e) => { var _a; return knownProjectiles.includes((_a = e.name) !== null && _a !== void 0 ? _a : "nope"); })) {
            const init = index_1.ShotFactory.fromEntity(entity, this.intercepter);
            const info = init.hitsEntity(aabbComponents);
            if (!!info)
                hittingArrows.push({ entity, info });
        }
        return hittingArrows;
    }
    getHighestPriorityProjectile() {
        var _a;
        return (_a = this.getIncomingProjectiles().sort((a, b) => a.info.totalTicks - b.info.totalTicks)[0]) !== null && _a !== void 0 ? _a : null;
    }
    allProjectileInfo() {
        const hittingArrows = [];
        const entities = Object.values(this.bot.entities);
        const knownProjectiles = Object.keys(index_1.projectileGravity);
        for (const entity of Object.values(this.bot.entities).filter((e) => { var _a; return knownProjectiles.includes((_a = e.name) !== null && _a !== void 0 ? _a : "nope"); })) {
            const init = index_1.ShotFactory.fromEntity(entity, this.intercepter);
            const info = init.calcToIntercept(true, entities);
            hittingArrows.push({ entity, info });
        }
        return hittingArrows;
    }
    getAimingMobs() {
        const hittingArrows = [];
        const aabbComponents = { position: this.bot.entity.position, height: this.bot.entity.height + 0.18, width: 0.3 };
        for (const entity of Object.values(this.bot.entities).filter((e) => { var _a; return e.name === "skeleton" || (e.name === "piglin" && ((_a = e.heldItem) === null || _a === void 0 ? void 0 : _a.name.includes("bow"))); })) {
            const init = index_1.ShotFactory.fromMob(entity, this.intercepter);
            const info = init.hitsEntity(aabbComponents);
            if (!!info)
                hittingArrows.push({ entity, info });
        }
        return hittingArrows;
    }
    //TODO: Make aim dynamic by reading heldItem metadata.
    getAimingPlayers() {
        var _a, _b, _c;
        const hittingArrows = [];
        const aabbComponents = { position: this.bot.entity.position, height: this.bot.entity.height + 0.18, width: 0.3 };
        const knownWeapons = Object.keys(index_1.trajectoryInfo);
        for (const entity of Object.values(this.bot.entities).filter((e) => e.type === "player" && e !== this.bot.entity)) {
            if (knownWeapons.includes((_b = (_a = entity.heldItem) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : (_c = entity.equipment[1]) === null || _c === void 0 ? void 0 : _c.name)) {
                const init = index_1.ShotFactory.fromPlayer(entity, this.intercepter);
                const info = init.hitsEntity(aabbComponents);
                if (!!info)
                    hittingArrows.push({ entity, info });
            }
        }
        return hittingArrows;
    }
    getAimingEntities() {
        return this.getAimingMobs().concat(this.getAimingPlayers());
    }
    getHighestPriorityEntity() {
        var _a;
        return (_a = this.getAimingEntities().sort((a, b) => a.info.totalTicks - b.info.totalTicks)[0]) !== null && _a !== void 0 ? _a : null;
    }
    getProjectileDestination(entity) {
        var _a;
        // const aabbComponents = { position: this.bot.entity.position, height: this.bot.entity.height + 0.18, width: 0.3 };
        const knownWeapons = Object.keys(index_1.trajectoryInfo);
        if (knownWeapons.includes((_a = entity.heldItem) === null || _a === void 0 ? void 0 : _a.name)) {
            let init;
            switch (entity.type) {
                case "player":
                    init = index_1.ShotFactory.fromPlayer(entity, this.intercepter);
                    break;
                case "mob":
                    init = index_1.ShotFactory.fromMob(entity, this.intercepter);
                    break;
                default:
                    throw `Invalid entity type: ${entity.type}`;
            }
            const info = init.hitsEntities(true, ...Object.values(this.bot.entities).filter((e) => (e.type === "player" || e.type === "mob") && e !== entity));
            return info;
        }
        return null;
    }
}
exports.ProjectileTracker = ProjectileTracker;
