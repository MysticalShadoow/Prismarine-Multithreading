"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Shot = void 0;
const vec3_1 = require("vec3");
const mathUtilts_1 = require("./calc/mathUtilts");
const constants_1 = require("./calc/constants");
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const { getBlockAABB, getBlockPosAABB, getEntityAABBRaw } = mineflayer_util_plugin_1.AABBUtils;
const mineflayer_util_plugin_2 = require("@nxg-org/mineflayer-util-plugin");
const emptyVec = new vec3_1.Vec3(0, 0, 0);
/**
 * TODO: Change hit detection from AABB -> Ray to AABB -> Moving AABB of 0.5h, 0.5w.
 * ! We are "missing" shots due to this miscalculation.
 * * DONE! WOOOOOOOOOO
 *
 * TODO: Completely rewrite arrow trajectory calculation. Currently using assumptions, can be much better.
 * ! It is very fast; I will have to optimize even more.
 * * DONE! WOOOOOOOOOO
 *
 * TODO: Work on caching arrow trajectories. This will speed up repeated look-ups and encourage reuse of classes to save RAM/CPU.
 *
 */
/**
 * uses:
 * (a) calculate shot based off current entities yaw and target
 * (b) calculate correct yaw and target
 * (c) better block detection
 * (d) velocity checks
 */
/**
 * Purposely left off prediction.
 * You can handle that outside of the Shot class.
 */
class Shot {
    constructor(originVel, { position: pPos, velocity: pVel, gravity }, interceptCalcs) {
        this.blockCheck = false;
        const { yaw, pitch } = (0, mathUtilts_1.dirToYawAndPitch)(pVel);
        this.initialPos = pPos.clone();
        this.initialVel = pVel.clone().add(originVel);
        this.gravity = gravity;
        this.initialYaw = yaw;
        this.initialPitch = pitch;
        this.interceptCalcs = interceptCalcs;
    }
    canCollisionDetect() {
        return !!this.interceptCalcs;
    }
    loadWorld(bot) {
        if (!this.interceptCalcs)
            this.interceptCalcs = new mineflayer_util_plugin_2.InterceptFunctions(bot);
    }
    HitCheckXZ(entity) {
        return !!this.entityXZInterceptCheck(entity);
    }
    entityXYZInterceptCheck({ position, height, width }) {
        return getEntityAABBRaw({ position, height, width }).intersectsRay(this.initialPos, this.initialVel);
    }
    entityXZInterceptCheck({ position, height, width }) {
        return getEntityAABBRaw({ position, height, width }).xzIntersectsRay(this.initialPos, this.initialVel);
    }
    hitEntitiesCheckXZ(...entities) {
        return entities
            .sort((a, b) => a.position.distanceTo(this.initialPos) - b.position.distanceTo(this.initialPos))
            .filter((e) => this.HitCheckXZ(e));
    }
    aabbHitCheckXZ(...aabbs) {
        if (!(aabbs instanceof mineflayer_util_plugin_2.AABB))
            aabbs = aabbs.map(getEntityAABBRaw);
        return aabbs
            .sort((a, b) => a.xzDistanceToVec(this.initialPos) - b.xzDistanceToVec(this.initialPos))
            .filter((box) => !!box.xzIntersectsRay(this.initialPos, this.initialVel));
    }
    hitEntitiesCheck(blockCheck = false, ...entities) {
        const shots = [];
        const possibleEntities = this.aabbHitCheckXZ(...entities);
        for (const entity of possibleEntities) {
            shots.push({ entity, shotInfo: this.calcToEntity(entity, blockCheck) });
        }
        return shots;
    }
    hitsEntity(entity, extras = { yawChecked: false, blockCheck: true }) {
        var _a;
        if (extras.yawChecked) {
            return { entity: entity, shotInfo: this.calcToEntity(entity, extras.blockCheck) };
        }
        else {
            const shotInfo = (_a = this.hitEntitiesCheck(extras.blockCheck, entity)[0]) === null || _a === void 0 ? void 0 : _a.shotInfo;
            return !!shotInfo ? { entity, shotInfo } : null;
        }
    }
    //TODO: Make this *not* lazy.
    hitsEntities(blockCheck = false, ...entities) {
        const hits = [];
        for (const info of this.hitEntitiesCheck(blockCheck, ...entities)) {
            const found = entities.find((e) => getEntityAABBRaw(e).equals(info.entity));
            hits.push({ entity: found, shotInfo: info.shotInfo });
        }
        return hits;
    }
    hitsEntityWithPrediction({ position, height, width }, avgSpeed) {
        //Ignore XZ check as we will check two different XZ coords.
        const calcShot = this.calcToEntity({ position, height, width });
        const { newTarget } = (0, mathUtilts_1.getPremonition)(this.initialPos, position.clone().add(avgSpeed.clone().scale(calcShot.totalTicks + 5)), avgSpeed, calcShot.totalTicks);
        const newAABB = getEntityAABBRaw({ position: newTarget, height, width });
        const calcPredictShot = this.calcToEntity(newAABB, true);
        return calcPredictShot;
    }
    /**
     *
     * @param {boolean} blockChecking Whether to check for blocks or not.
     * @param {Entity[]} Entity list of entities from Prismarine-entity.
     * @returns TODO: Typing
     */
    calcToIntercept(blockChecking = false, entities = []) {
        var _a;
        const entityAABBs = entities
            .sort((a, b) => this.initialPos.distanceTo(a.position) - this.initialPos.distanceTo(b.position))
            .map((e) => getEntityAABBRaw(e)); //slightly inaccurate.
        let currentPosition = this.initialPos.clone();
        let currentVelocity = this.initialVel.clone();
        let nextPosition = currentPosition.clone().add(currentVelocity);
        let hitPos = null;
        let block = null;
        let totalTicks = 0;
        const gravity = this.gravity; // + this.gravity * airResistance.y;
        let offsetX = -currentVelocity.x * constants_1.airResistance.h;
        let offsetY = -currentVelocity.y * constants_1.airResistance.y - gravity;
        let offsetZ = -currentVelocity.z * constants_1.airResistance.h;
        while (totalTicks < 300) {
            totalTicks += 1;
            offsetX = -currentVelocity.x * constants_1.airResistance.h;
            offsetY = -currentVelocity.y * constants_1.airResistance.y - gravity;
            offsetZ = -currentVelocity.z * constants_1.airResistance.h;
            if (blockChecking && this.interceptCalcs) {
                block = (_a = this.interceptCalcs.check(currentPosition, nextPosition)) === null || _a === void 0 ? void 0 : _a.block;
            }
            if (block) {
                const blockAABB = getBlockAABB(block);
                hitPos = blockAABB.intersectsSegment(currentPosition, nextPosition);
                break;
            }
            //TODO:  Make this check more efficient by checking from line, not from entity AABBs.
            const hits = entityAABBs.map((aabb) => aabb.intersectsSegment(currentPosition, nextPosition)).filter((vec) => !!vec);
            if (hits.length > 0) {
                hitPos = hits[0]; //sorted for distance already.
                break;
            }
            if (currentVelocity.y < 0 && currentPosition.y < 0)
                break;
            currentPosition.add(currentVelocity);
            currentVelocity.translate(offsetX, offsetY, offsetZ);
            nextPosition.add(currentVelocity);
        }
        return {
            block,
            hitPos,
            totalTicks,
        };
    }
    calcToEntity(target, blockChecking = false) {
        var _a;
        if (!(target instanceof mineflayer_util_plugin_2.AABB))
            target = getEntityAABBRaw(target);
        // height = height = 1.62 ? height + 0.18 : 0;
        const entityAABB = target;
        let currentPosition = this.initialPos.clone();
        let currentVelocity = this.initialVel.clone();
        let perTickVel = currentVelocity.clone();
        let nearestDistance = entityAABB.distanceToVec(currentPosition);
        let nextPosition = currentPosition.clone().add(currentVelocity);
        let currentDist = currentPosition.xzDistanceTo(currentPosition);
        let intersectPos = null;
        let blockingBlock = null;
        let closestPoint = null;
        let totalTicks = 0;
        let gravity = this.gravity; // + this.gravity * airResistance.y;
        let offsetX = -perTickVel.x * constants_1.airResistance.h;
        let offsetY = -perTickVel.y * constants_1.airResistance.y - gravity;
        let offsetZ = -perTickVel.z * constants_1.airResistance.h;
        const entityDist = target.xzDistanceToVec(this.initialPos);
        while (totalTicks < 300) {
            const testDist = entityAABB.distanceToVec(currentPosition);
            // if (nearestDistance !== testDist) {
            //     if (nearestDistance > 6) {
            //         totalTicks += 1;
            //         gravity = this.gravity; // - this.gravity * airResistance.y;
            //         offsetX = -perTickVel.x * airResistance.h;
            //         offsetY = -perTickVel.y * airResistance.y - gravity;
            //         offsetZ = -perTickVel.z * airResistance.h;
            //     } else {
            //         totalTicks += 0.2;
            //         gravity = this.gravity * 0.2; //- this.gravity * airResistance.y) * 0.2
            //         offsetX = -perTickVel.x * (airResistance.h * 0.2);
            //         offsetY = -perTickVel.y * (airResistance.y * 0.2) - gravity;
            //         offsetZ = -perTickVel.z * (airResistance.h * 0.2);
            //     }
            // }
            totalTicks++;
            offsetX = -perTickVel.x * constants_1.airResistance.h;
            offsetY = -perTickVel.y * constants_1.airResistance.y - this.gravity;
            offsetZ = -perTickVel.z * constants_1.airResistance.h;
            if (nearestDistance > testDist) {
                nearestDistance = testDist;
                closestPoint = currentPosition;
            }
            if (blockChecking && this.interceptCalcs) {
                blockingBlock = (_a = this.interceptCalcs.check(currentPosition, nextPosition)) === null || _a === void 0 ? void 0 : _a.block;
            }
            if (blockingBlock)
                break;
            intersectPos = entityAABB.intersectsSegment(currentPosition, nextPosition);
            if (intersectPos) {
                nearestDistance = 0;
                closestPoint = intersectPos;
                break;
            }
            currentDist = currentPosition.xzDistanceTo(this.initialPos);
            if (currentDist > entityDist || (currentVelocity.y < 0 && currentPosition.y - target.minY < 0))
                break;
            currentPosition.add(currentVelocity);
            currentVelocity.translate(offsetX, offsetY, offsetZ);
            if (totalTicks % 1 === 0)
                perTickVel = currentVelocity;
            nextPosition.add(currentVelocity);
        }
        return {
            nearestDistance,
            blockingBlock,
            intersectPos,
            closestPoint,
            totalTicks,
        };
    }
}
exports.Shot = Shot;
