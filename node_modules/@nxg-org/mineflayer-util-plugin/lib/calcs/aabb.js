"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AABB = void 0;
const vec3_1 = require("vec3");
function lerp(f, f2, f3) {
    return f2 + f * (f3 - f2);
}
const emptyVec = new vec3_1.Vec3(0, 0, 0);
class AABB {
    constructor(x0, y0, z0, x1, y1, z1) {
        this.minX = x0;
        this.minY = y0;
        this.minZ = z0;
        this.maxX = x1;
        this.maxY = y1;
        this.maxZ = z1;
    }
    static fromVecs(min, max) {
        return new AABB(min.x, min.y, min.z, max.x, max.y, max.z);
    }
    static fromBlock(min) {
        return new AABB(min.x, min.y, min.z, min.x + 1.0, min.y + 1.0, min.z + 1.0);
    }
    static fromShape(pts, offset = emptyVec) {
        return new AABB(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]).translateVec(offset);
    }
    set(x0, y0, z0, x1, y1, z1) {
        this.minX = x0;
        this.minY = y0;
        this.minZ = z0;
        this.maxX = x1;
        this.maxY = y1;
        this.maxZ = z1;
    }
    clone() {
        return new AABB(this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);
    }
    minPoint() {
        return new vec3_1.Vec3(this.minX, this.minY, this.minZ);
    }
    maxPoint() {
        return new vec3_1.Vec3(this.maxX, this.maxY, this.maxZ);
    }
    bottomMiddlePoint() {
        return new vec3_1.Vec3((this.maxX - this.minX) / 2, this.minY, (this.maxZ - this.minZ) / 2);
    }
    heightAndWidths() {
        return new vec3_1.Vec3(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
    }
    toArray() {
        return [this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ];
    }
    minAndMaxArrays() {
        return [
            [this.minX, this.minY, this.minZ],
            [this.maxX, this.maxY, this.maxZ],
        ];
    }
    toVecs() {
        return [new vec3_1.Vec3(this.minX, this.minY, this.minZ), new vec3_1.Vec3(this.maxX, this.maxY, this.maxZ)];
    }
    /**
     * Compatible with Iterators from prismarine-world.
     * Used like a block for prismarine-world.
     * @returns {number[][]} single element long array of shapes.
     */
    toShapeFromMin() {
        return [[0, 0, 0, this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ]];
    }
    /**
     * Compatible with Iterators from prismarine-world.
     * Used with the entity's actual position for prismarine-world.
     * @returns {number[][]} single element long array of shapes.
     */
    toShapeFromBottomMiddle() {
        const wx = (this.maxX - this.minX) / 2;
        const wz = (this.maxZ - this.minZ) / 2;
        return [[-wx, 0, -wz, wx, this.maxY - this.minY, wz]];
    }
    toVertices() {
        return [
            new vec3_1.Vec3(this.minX, this.minY, this.minZ),
            new vec3_1.Vec3(this.minX, this.minY, this.maxZ),
            new vec3_1.Vec3(this.minX, this.maxY, this.minZ),
            new vec3_1.Vec3(this.minX, this.maxY, this.maxZ),
            new vec3_1.Vec3(this.maxX, this.minY, this.minZ),
            new vec3_1.Vec3(this.maxX, this.minY, this.maxZ),
            new vec3_1.Vec3(this.maxX, this.maxY, this.minZ),
            new vec3_1.Vec3(this.maxX, this.maxY, this.maxZ),
        ];
    }
    floor() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.minZ = Math.floor(this.minZ);
        this.maxX = Math.floor(this.maxX);
        this.maxY = Math.floor(this.maxY);
        this.maxZ = Math.floor(this.maxZ);
        return this;
    }
    extend(dx, dy, dz) {
        if (dx < 0)
            this.minX += dx;
        else
            this.maxX += dx;
        if (dy < 0)
            this.minY += dy;
        else
            this.maxY += dy;
        if (dz < 0)
            this.minZ += dz;
        else
            this.maxZ += dz;
        return this;
    }
    contract(x, y, z) {
        this.minX += x;
        this.minY += y;
        this.minZ += z;
        this.maxX -= x;
        this.maxY -= y;
        this.maxZ -= z;
        return this;
    }
    expand(x, y, z) {
        this.minX -= x;
        this.minY -= y;
        this.minZ -= z;
        this.maxX += x;
        this.maxY += y;
        this.maxZ += z;
        return this;
    }
    translate(x, y, z) {
        this.minX += x;
        this.minY += y;
        this.minZ += z;
        this.maxX += x;
        this.maxY += y;
        this.maxZ += z;
        return this;
    }
    translateVec(vec) {
        this.minX += vec.x;
        this.minY += vec.y;
        this.minZ += vec.z;
        this.maxX += vec.x;
        this.maxY += vec.y;
        this.maxZ += vec.z;
        return this;
    }
    computeOffsetX(other, offsetX) {
        if (other.maxY > this.minY && other.minY < this.maxY && other.maxZ > this.minZ && other.minZ < this.maxZ) {
            if (offsetX > 0.0 && other.maxX <= this.minX) {
                offsetX = Math.min(this.minX - other.maxX, offsetX);
            }
            else if (offsetX < 0.0 && other.minX >= this.maxX) {
                offsetX = Math.max(this.maxX - other.minX, offsetX);
            }
        }
        return offsetX;
    }
    computeOffsetY(other, offsetY) {
        if (other.maxX > this.minX && other.minX < this.maxX && other.maxZ > this.minZ && other.minZ < this.maxZ) {
            if (offsetY > 0.0 && other.maxY <= this.minY) {
                offsetY = Math.min(this.minY - other.maxY, offsetY);
            }
            else if (offsetY < 0.0 && other.minY >= this.maxY) {
                offsetY = Math.max(this.maxY - other.minY, offsetY);
            }
        }
        return offsetY;
    }
    computeOffsetZ(other, offsetZ) {
        if (other.maxX > this.minX && other.minX < this.maxX && other.maxY > this.minY && other.minY < this.maxY) {
            if (offsetZ > 0.0 && other.maxZ <= this.minZ) {
                offsetZ = Math.min(this.minZ - other.maxZ, offsetZ);
            }
            else if (offsetZ < 0.0 && other.minZ >= this.maxZ) {
                offsetZ = Math.max(this.maxZ - other.minZ, offsetZ);
            }
        }
        return offsetZ;
    }
    intersects(other) {
        return (this.minX < other.maxX &&
            this.maxX > other.minX &&
            this.minY < other.maxY &&
            this.maxY > other.minY &&
            this.minZ < other.maxZ &&
            this.maxZ > other.minZ);
    }
    xzIntersectsRay(org, dir) {
        const d = this.distanceFromRay(org, dir, true);
        return d === Infinity ? null : { x: org.x + dir.x * d, z: org.z + dir.z * d };
    }
    intersectsRay(org, dir) {
        const d = this.distanceFromRay(org, dir);
        return d === Infinity ? null : new vec3_1.Vec3(org.x + dir.x * d, org.y + dir.y * d, org.z + dir.z * d);
    }
    //TODO: Better check for hit reg of PLANES.
    xzIntersectsSegment(org, dest) {
        const dir = dest.clone().subtract(org).normalize();
        const d = this.distanceFromRay(org, dir, true);
        return d > dest.distanceTo(org) || d < 0 ? null : { x: org.x + dir.x * d, z: org.z + dir.z * d };
    }
    //TODO: Better check for hit reg of PLANES.
    intersectsSegment(org, dest) {
        const dir = dest.clone().subtract(org).normalize();
        const d = this.distanceFromRay(org, dir);
        return d > dest.distanceTo(org) || d < 0 ? null : new vec3_1.Vec3(org.x + dir.x * d, org.y + dir.y * d, org.z + dir.z * d);
    }
    distanceFromRay(origin, direction, xz = false) {
        const ro = origin.toArray();
        const rd = direction.clone().normalize().toArray();
        const aabb = this.minAndMaxArrays();
        const dims = ro.length; // will change later.
        const dif = xz ? 2 : 1;
        let lo = -Infinity;
        let hi = +Infinity;
        // let test = origin.clone()
        for (let i = 0; i < dims; i += dif) {
            let dimLo = (aabb[0][i] - ro[i]) / rd[i];
            let dimHi = (aabb[1][i] - ro[i]) / rd[i];
            if (dimLo > dimHi) {
                let tmp = dimLo;
                dimLo = dimHi;
                dimHi = tmp;
            }
            if (dimHi < lo || dimLo > hi) {
                return Infinity;
            }
            if (dimLo > lo)
                lo = dimLo;
            if (dimHi < hi)
                hi = dimHi;
        }
        return lo > hi ? Infinity : lo;
    }
    intersect(aABB) {
        const d = Math.max(this.minX, aABB.minX);
        const d2 = Math.max(this.minY, aABB.minY);
        const d3 = Math.max(this.minZ, aABB.minZ);
        const d4 = Math.min(this.maxX, aABB.maxX);
        const d5 = Math.min(this.maxY, aABB.maxY);
        const d6 = Math.min(this.maxZ, aABB.maxZ);
        return new AABB(d, d2, d3, d4, d5, d6);
    }
    equals(other) {
        return (this.minX === other.minX &&
            this.minY === other.minY &&
            this.minZ === other.minZ &&
            this.maxX === other.maxX &&
            this.maxY === other.maxY &&
            this.maxZ === other.maxZ);
    }
    xzDistanceToVec(pos) {
        let dx = Math.max(this.minX - pos.x, 0, pos.x - this.maxX);
        let dz = Math.max(this.minZ - pos.z, 0, pos.z - this.maxZ);
        return Math.sqrt(dx * dx + dz * dz);
    }
    distanceToVec(pos) {
        let dx = Math.max(this.minX - pos.x, 0, pos.x - this.maxX);
        let dy = Math.max(this.minY - pos.y, 0, pos.y - this.maxY);
        let dz = Math.max(this.minZ - pos.z, 0, pos.z - this.maxZ);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    expandTowards(vec3) {
        return this.expandTowardsCoords(vec3.x, vec3.y, vec3.z);
    }
    expandTowardsCoords(d, d2, d3) {
        let d4 = this.minX;
        let d5 = this.minY;
        let d6 = this.minZ;
        let d7 = this.maxX;
        let d8 = this.maxY;
        let d9 = this.maxZ;
        if (d < 0.0) {
            d4 += d;
        }
        else if (d > 0.0) {
            d7 += d;
        }
        if (d2 < 0.0) {
            d5 += d2;
        }
        else if (d2 > 0.0) {
            d8 += d2;
        }
        if (d3 < 0.0) {
            d6 += d3;
        }
        else if (d3 > 0.0) {
            d9 += d3;
        }
        return new AABB(d4, d5, d6, d7, d8, d9);
    }
    moveCoords(d, d2, d3) {
        return new AABB(this.minX + d, this.minY + d2, this.minZ + d3, this.maxX + d, this.maxY + d2, this.maxZ + d3);
    }
    move(vec3) {
        return new AABB(this.minX + vec3.x, this.minY + vec3.y, this.minZ + vec3.z, this.maxX + vec3.x, this.maxY + vec3.y, this.maxZ + vec3.z);
    }
    intersectsCoords(d, d2, d3, d4, d5, d6) {
        return this.minX < d4 && this.maxX > d && this.minY < d5 && this.maxY > d2 && this.minZ < d6 && this.maxZ > d3;
    }
    collides(aABB) {
        return this.collidesCoords(aABB.minX, aABB.minY, aABB.minZ, aABB.maxX, aABB.maxY, aABB.maxZ);
    }
    collidesCoords(d, d2, d3, d4, d5, d6) {
        return (this.minX <= d4 && this.maxX >= d && this.minY <= d5 && this.maxY >= d2 && this.minZ <= d6 && this.maxZ >= d3);
    }
    containsVec(vec) {
        return (this.minX <= vec.x &&
            this.maxX >= vec.x &&
            this.minY <= vec.y &&
            this.maxY >= vec.y &&
            this.minZ <= vec.z &&
            this.maxZ >= vec.z);
    }
    contains(x, y, z) {
        return this.minX <= x && this.maxX >= x && this.minY <= y && this.maxY >= y && this.minZ <= z && this.maxZ >= z;
    }
    getCenter() {
        return new vec3_1.Vec3(lerp(0.5, this.minX, this.maxX), lerp(0.5, this.minY, this.maxY), lerp(0.5, this.minZ, this.maxZ));
    }
}
exports.AABB = AABB;
exports.default = AABB;
