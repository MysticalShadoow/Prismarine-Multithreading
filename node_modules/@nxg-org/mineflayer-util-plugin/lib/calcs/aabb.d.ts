import { Vec3 } from "vec3";
type FakeVec3 = {
    x: number;
    y: number;
    z: number;
};
type AABBPoints = [minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number];
type MinAndMaxPoints = [min: [x: number, y: number, z: number], max: [x: number, y: number, z: number]];
type Vec3AABB = [min: Vec3, max: Vec3];
export declare class AABB {
    minX: number;
    minY: number;
    minZ: number;
    maxX: number;
    maxY: number;
    maxZ: number;
    constructor(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number);
    static fromVecs(min: FakeVec3, max: FakeVec3): AABB;
    static fromBlock(min: FakeVec3): AABB;
    static fromShape(pts: AABBPoints, offset?: Vec3): AABB;
    set(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): void;
    clone(): AABB;
    minPoint(): Vec3;
    maxPoint(): Vec3;
    bottomMiddlePoint(): Vec3;
    heightAndWidths(): Vec3;
    toArray(): AABBPoints;
    minAndMaxArrays(): MinAndMaxPoints;
    toVecs(): Vec3AABB;
    /**
     * Compatible with Iterators from prismarine-world.
     * Used like a block for prismarine-world.
     * @returns {number[][]} single element long array of shapes.
     */
    toShapeFromMin(): AABBPoints[];
    /**
     * Compatible with Iterators from prismarine-world.
     * Used with the entity's actual position for prismarine-world.
     * @returns {number[][]} single element long array of shapes.
     */
    toShapeFromBottomMiddle(): AABBPoints[];
    toVertices(): Vec3[];
    floor(): this;
    extend(dx: number, dy: number, dz: number): this;
    contract(x: number, y: number, z: number): this;
    expand(x: number, y: number, z: number): this;
    translate(x: number, y: number, z: number): this;
    translateVec(vec: FakeVec3): this;
    computeOffsetX(other: AABB, offsetX: number): number;
    computeOffsetY(other: AABB, offsetY: number): number;
    computeOffsetZ(other: AABB, offsetZ: number): number;
    intersects(other: AABB): boolean;
    xzIntersectsRay(org: Vec3, dir: Vec3): {
        x: number;
        z: number;
    } | null;
    intersectsRay(org: Vec3, dir: Vec3): Vec3 | null;
    xzIntersectsSegment(org: Vec3, dest: Vec3): {
        x: number;
        z: number;
    } | null;
    intersectsSegment(org: Vec3, dest: Vec3): Vec3 | null;
    distanceFromRay(origin: Vec3, direction: Vec3, xz?: boolean): number;
    intersect(aABB: AABB): AABB;
    equals(other: AABB): boolean;
    xzDistanceToVec(pos: FakeVec3): number;
    distanceToVec(pos: FakeVec3): number;
    expandTowards(vec3: FakeVec3): AABB;
    expandTowardsCoords(d: number, d2: number, d3: number): AABB;
    moveCoords(d: number, d2: number, d3: number): AABB;
    move(vec3: FakeVec3): AABB;
    intersectsCoords(d: number, d2: number, d3: number, d4: number, d5: number, d6: number): boolean;
    collides(aABB: AABB): boolean;
    collidesCoords(d: number, d2: number, d3: number, d4: number, d5: number, d6: number): boolean;
    containsVec(vec: FakeVec3): boolean;
    contains(x: number, y: number, z: number): boolean;
    getCenter(): Vec3;
}
export default AABB;
