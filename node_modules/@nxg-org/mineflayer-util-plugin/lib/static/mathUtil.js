"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathUtils = void 0;
const vec3_1 = require("vec3");
var MathUtils;
(function (MathUtils) {
    const PI = Math.PI;
    const PI_2 = Math.PI * 2;
    MathUtils.TO_RAD = PI / 180;
    MathUtils.TO_DEG = 1 / MathUtils.TO_RAD;
    MathUtils.FROM_NOTCH_BYTE = 360 / 256;
    // From wiki.vg: Velocity is believed to be in units of 1/8000 of a block per server tick (50ms)
    MathUtils.FROM_NOTCH_VEL = 1 / 8000;
    MathUtils.toNotchianYaw = (yaw) => toDegrees(PI - yaw);
    MathUtils.toNotchianPitch = (pitch) => toDegrees(-pitch);
    MathUtils.fromNotchianYawByte = (yaw) => fromNotchianYaw(yaw * MathUtils.FROM_NOTCH_BYTE);
    MathUtils.fromNotchianPitchByte = (pitch) => fromNotchianPitch(pitch * MathUtils.FROM_NOTCH_BYTE);
    function euclideanMod(numerator, denominator) {
        const result = numerator % denominator;
        return result < 0 ? result + denominator : result;
    }
    MathUtils.euclideanMod = euclideanMod;
    function toRadians(degrees) {
        return MathUtils.TO_RAD * degrees;
    }
    MathUtils.toRadians = toRadians;
    function toDegrees(radians) {
        return MathUtils.TO_DEG * radians;
    }
    MathUtils.toDegrees = toDegrees;
    function fromNotchianYaw(yaw) {
        return euclideanMod(PI - toRadians(yaw), PI_2);
    }
    MathUtils.fromNotchianYaw = fromNotchianYaw;
    function fromNotchianPitch(pitch) {
        return euclideanMod(toRadians(-pitch) + PI, PI_2) - PI;
    }
    MathUtils.fromNotchianPitch = fromNotchianPitch;
    function fromNotchVelocity(vel) {
        return new vec3_1.Vec3(vel.x * MathUtils.FROM_NOTCH_VEL, vel.y * MathUtils.FROM_NOTCH_VEL, vel.z * MathUtils.FROM_NOTCH_VEL);
    }
    MathUtils.fromNotchVelocity = fromNotchVelocity;
    function pointToYawAndPitch(bot, point) {
        const delta = point.minus(bot.entity.position.offset(0, bot.entity.height, 0));
        return dirToYawAndPitch(delta);
    }
    MathUtils.pointToYawAndPitch = pointToYawAndPitch;
    function dirToYawAndPitch(dir) {
        const yaw = Math.atan2(-dir.x, -dir.z);
        const groundDistance = Math.sqrt(dir.x * dir.x + dir.z * dir.z);
        const pitch = Math.atan2(dir.y, groundDistance);
        return { yaw: yaw, pitch: pitch };
    }
    MathUtils.dirToYawAndPitch = dirToYawAndPitch;
    function getYaw(origin, destination) {
        const xDistance = destination.x - origin.x;
        const zDistance = destination.z - origin.z;
        const yaw = Math.atan2(xDistance, zDistance) + Math.PI;
        return yaw;
    }
    MathUtils.getYaw = getYaw;
    function getViewDir(pitch, yaw) {
        return new vec3_1.Vec3(-Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw) * Math.cos(pitch));
    }
    MathUtils.getViewDir = getViewDir;
    function yawPitchAndSpeedToDir(yaw, pitch, speed) {
        return new vec3_1.Vec3(-Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw) * Math.cos(pitch)).scale(speed);
    }
    MathUtils.yawPitchAndSpeedToDir = yawPitchAndSpeedToDir;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));
