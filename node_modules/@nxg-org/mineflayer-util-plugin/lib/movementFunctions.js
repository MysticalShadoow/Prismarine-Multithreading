"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovementFunctions = exports.lerp = void 0;
const vec3_1 = require("vec3");
const static_1 = require("./static");
function lerp(f, f2, f3) {
    return f2 + f * (f3 - f2);
}
exports.lerp = lerp;
function* interpolate(start, end, steps = 1) {
    for (let i = 0; i < steps; i++) {
        yield new vec3_1.Vec3(lerp(i / steps, start.x, end.x), lerp(i / steps, start.y, end.y), lerp(i / steps, start.z, end.z));
    }
}
class MovementFunctions {
    constructor(bot) {
        this.bot = bot;
    }
    forceLook(yaw, pitch, update = false, onGround) {
        const notchianYawAndPitch = { yaw: static_1.MathUtils.toNotchianYaw(yaw), pitch: static_1.MathUtils.toNotchianPitch(pitch) };
        this.bot._client.write("look", Object.assign(Object.assign({}, notchianYawAndPitch), { onGround: onGround !== null && onGround !== void 0 ? onGround : this.bot.entity.onGround }));
        if (update) {
            this.bot.look(yaw, pitch, true);
            this.bot.entity.pitch = pitch;
            this.bot.entity.yaw = yaw;
        }
    }
    forceLookAt(pos, update = false, onGround) {
        const { yaw, pitch } = static_1.MathUtils.pointToYawAndPitch(this.bot, pos);
        const nyp = { yaw: static_1.MathUtils.toNotchianYaw(yaw), pitch: static_1.MathUtils.toNotchianPitch(pitch) };
        this.bot._client.write("look", Object.assign(Object.assign({}, nyp), { onGround: onGround !== null && onGround !== void 0 ? onGround : this.bot.entity.onGround }));
        if (update) {
            this.bot.look(yaw, pitch, true);
            this.bot.entity.pitch = pitch;
            this.bot.entity.yaw = yaw;
        }
    }
    lazyTeleport(endPos, steps = 1, update = false) {
        for (const pos of interpolate(this.bot.entity.position, endPos, steps)) {
            const block = this.bot.blockAt(pos.offset(0, -0.01, 0));
            if (!block)
                break;
            this.bot._client.write("position", Object.assign(Object.assign({}, pos), { onGround: block.transparent }));
        }
        if (update)
            this.bot.entity.position.set(endPos.x, endPos.y, endPos.z);
    }
}
exports.MovementFunctions = MovementFunctions;
