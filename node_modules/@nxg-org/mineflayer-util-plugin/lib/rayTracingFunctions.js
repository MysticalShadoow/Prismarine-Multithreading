"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RayTraceFunctions = void 0;
const vec3_1 = require("vec3");
const iterators_1 = require("./calcs/iterators");
const static_1 = require("./static");
class RayTraceFunctions {
    constructor(bot) {
        this.bot = bot;
    }
    entityRaytrace(startPos, dir, maxDistance = 3.5, matcher) {
        matcher || (matcher = (e) => true);
        const aabbMap = {};
        Object.values(this.bot.entities)
            .filter((e) => e.username !== this.bot.entity.username && matcher(e))
            .forEach((e) => (aabbMap[e.id] = static_1.AABBUtils.getEntityAABB(e)));
        return this.entityRaytraceRaw(startPos, dir, aabbMap, maxDistance, matcher);
    }
    entityRaytraceRaw(startPos, dir, aabbMap, maxDistance = 3.5, matcher) {
        var _a;
        matcher || (matcher = (e) => true);
        const eyePos = this.bot.entity.position.offset(0, this.bot.entity.height, 0);
        Object.entries(aabbMap).forEach(([id, bb]) => {
            if (bb.distanceToVec(eyePos) > maxDistance)
                delete aabbMap[id];
        });
        dir = dir.normalize();
        let returnVal = this.bot.world.raycast(startPos, dir, maxDistance);
        if (returnVal && Object.keys(aabbMap).length === 0)
            return returnVal;
        maxDistance = (_a = returnVal === null || returnVal === void 0 ? void 0 : returnVal.intersect.distanceTo(startPos)) !== null && _a !== void 0 ? _a : maxDistance;
        const iterator = new iterators_1.RaycastIterator(startPos, dir, maxDistance);
        for (const id in aabbMap) {
            const aabb = aabbMap[id];
            const pt = aabb.minPoint();
            const entity = this.bot.entities[id];
            const intersect = iterator.intersect(aabb.toShapeFromMin(), pt);
            if (intersect) {
                const entityDir = pt.minus(eyePos);
                const sign = Math.sign(entityDir.dot(dir));
                if (sign !== -1) {
                    const dist = eyePos.distanceTo(intersect.pos);
                    if (dist <= maxDistance) {
                        maxDistance = dist;
                        if (matcher(entity)) {
                            returnVal = entity;
                            returnVal.intersect = intersect.pos;
                            returnVal.face = intersect.face;
                        }
                    }
                }
            }
        }
        return returnVal;
    }
    entityAtEntityCursor(entity, maxDistance = 3.5) {
        var _a;
        const block = this.bot.blockAtCursor(maxDistance);
        maxDistance = (_a = block === null || block === void 0 ? void 0 : block.intersect.distanceTo(this.bot.entity.position)) !== null && _a !== void 0 ? _a : maxDistance;
        const entities = Object.values(this.bot.entities).filter((e) => e.type !== "object" && e.username !== entity.username && e.position.distanceTo(entity.position) <= maxDistance);
        const dir = new vec3_1.Vec3(-Math.sin(entity.yaw) * Math.cos(entity.pitch), Math.sin(entity.pitch), -Math.cos(entity.yaw) * Math.cos(entity.pitch));
        const iterator = new iterators_1.RaycastIterator(entity.position.offset(0, entity.height, 0), dir.normalize(), maxDistance);
        let targetEntity = null;
        let targetDist = maxDistance;
        for (let i = 0; i < entities.length; i++) {
            const e = entities[i];
            const w = (e.height >= 1.62 && e.height <= 1.99) || e.height === 2.9 ? 0.3 : e.height / 2;
            const shapes = [[-w, 0, -w, w, e.height + (e.height === 1.62 ? 0.18 : 0), w]];
            const intersect = iterator.intersect(shapes, e.position);
            if (intersect) {
                const entityDir = e.position.minus(entity.position); // Can be combined into 1 line
                const sign = Math.sign(entityDir.dot(dir));
                if (sign !== -1) {
                    const dist = entity.position.distanceTo(intersect.pos);
                    if (dist < targetDist) {
                        targetEntity = e;
                        targetDist = dist;
                    }
                }
            }
        }
        return targetEntity;
    }
}
exports.RayTraceFunctions = RayTraceFunctions;
