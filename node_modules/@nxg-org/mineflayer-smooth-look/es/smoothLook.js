var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { dirToEuler, lookingAtEuler, targetEuler, yawPitchToDir } from "./lookUtil";
import TWEEN from "@tweenjs/tween.js";
export class SmoothLook {
    constructor(bot, debug = false) {
        this.bot = bot;
        this.debug = debug;
        this.currentlyLooking = false;
        this.easing = TWEEN.Easing.Elastic.Out;
        this._task = null;
    }
    setEasing(func) {
        this.easing = func;
    }
    /**
     * Wraps the euler so the walk from start to finish is clean,
     * no snapback when neg to pos values.
     */
    _wrapRotationEuler(start, dest) {
        if (Math.abs(start.x - dest.x) > Math.PI)
            dest.x = dest.x + 2 * Math.sign(start.x - dest.x) * Math.PI;
        return dest;
    }
    /**
     * Build custom Tween that interacts w/ the bot object
     * and cleans itself up once finishing.
     */
    _buildTask(start, dest, duration) {
        return new TWEEN.Tween(start)
            .to(dest, duration)
            .easing(this.easing)
            .onUpdate((current) => {
            this.bot.look(current.x, current.y, true);
        })
            .onComplete((current) => {
            if (this._task && this._task._chainedTweens.length === 0) {
                this._task = null;
            }
        });
    }
    /**
     * Unused. Would clean up internal tasks.
     */
    _cleanupTasks(chained = true) {
        if (this._task) {
            this._task.stop();
            if (chained)
                this._task.stopChainedTweens();
            this._task = null;
        }
    }
    /**
     * Used by force value. Cancel current task,
     * then start on current tween value to wanted destination.
     * This smoothly connects tweens (standard chaining is broken).
     */
    _launchNextTaskFromCancel(dest, duration) {
        if (this._task) {
            this._task
                .onStop((current) => {
                this._task = this._buildTask(current, this._wrapRotationEuler(current, dest), duration);
                this._task.start();
            })
                .stop();
        }
    }
    /**
     * Used by non-force. Wait for current task to end,
     * then begin new task from current position.
     * This does not cancel the current task and overrides the initial custom task clear.
     */
    eventuallyChain(dest, duration) {
        if (this._task) {
            this._task.onComplete((current) => {
                this._task = this._buildTask(current, this._wrapRotationEuler(current, dest), duration).start();
            });
        }
    }
    look(yaw, pitch, duration = 1000, force = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.lookTowards(yawPitchToDir(yaw, pitch), duration, force);
        });
    }
    lookTowards(dir, duration = 1000, force = true) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const startRotation = lookingAtEuler(this.bot.entity.yaw, this.bot.entity.pitch);
            const endRotation = dirToEuler(dir);
            this._wrapRotationEuler(startRotation, endRotation);
            if (((_a = this._task) === null || _a === void 0 ? void 0 : _a.isPlaying()) && !force) {
                this._debug("task running + not forcing.", TWEEN.getAll().length, "tasks.");
                this.eventuallyChain(endRotation, duration);
            }
            else if (((_b = this._task) === null || _b === void 0 ? void 0 : _b.isPlaying()) && force) {
                this._debug("task running + forcing.", TWEEN.getAll().length, "tasks.");
                this._launchNextTaskFromCancel(endRotation, duration);
            }
            else if (!((_c = this._task) === null || _c === void 0 ? void 0 : _c.isPlaying())) {
                this._debug("task not running, making new.", TWEEN.getAll().length, "tasks.");
                this._task = this._buildTask(startRotation, endRotation, duration);
                this._task.start();
            }
        });
    }
    lookAt(target, duration = 1000, force = true) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const startRotation = lookingAtEuler(this.bot.entity.yaw, this.bot.entity.pitch);
            const endRotation = targetEuler(this.bot.entity.position.offset(0, this.bot.entity.height, 0), target);
            this._wrapRotationEuler(startRotation, endRotation);
            if (((_a = this._task) === null || _a === void 0 ? void 0 : _a.isPlaying()) && !force) {
                this._debug("task running + not forcing.", TWEEN.getAll().length, "tasks.");
                this.eventuallyChain(endRotation, duration);
            }
            else if (((_b = this._task) === null || _b === void 0 ? void 0 : _b.isPlaying()) && force) {
                this._debug("task running + forcing.", TWEEN.getAll().length, "tasks.");
                this._launchNextTaskFromCancel(endRotation, duration);
            }
            else if (!((_c = this._task) === null || _c === void 0 ? void 0 : _c.isPlaying())) {
                this._debug("task not running, making new.", TWEEN.getAll().length, "tasks.");
                this._task = this._buildTask(startRotation, endRotation, duration);
                this._task.start();
            }
        });
    }
    _debug(message, ...optionalParams) {
        if (this.debug)
            console.log(message, ...optionalParams);
    }
}
