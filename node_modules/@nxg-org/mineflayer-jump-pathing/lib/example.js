"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mineflayer_1 = require("mineflayer");
const mineflayer_util_plugin_1 = __importDefault(require("@nxg-org/mineflayer-util-plugin"));
const mineflayer_tracker_1 = __importDefault(require("@nxg-org/mineflayer-tracker"));
const vec3_1 = require("vec3");
const jumpPather_1 = require("./jumpPather");
const goals_1 = require("./goals");
const bot = (0, mineflayer_1.createBot)({
    username: "jump-pathing",
    host: "localhost",
    port: 25565,
    version: "1.17.1",
});
bot.physics.yawSpeed = 50;
bot.loadPlugin(mineflayer_util_plugin_1.default);
bot.loadPlugin(mineflayer_tracker_1.default);
const clas = new jumpPather_1.JumpPathing(bot);
function parseMessage(username, message) {
    console.log("<" + username + "> " + message);
    const msg = message.split(" ");
    switch (msg[0].toLowerCase()) {
        case "inventory":
            const item = bot.util.inv.findItem(msg[1]);
            if (item)
                bot.util.inv.customEquip(item, msg[2]);
            break;
        case "walk":
            bot.setControlState("forward", true);
            break;
        case "run":
            bot.setControlState("forward", true);
            bot.setControlState("sprint", true);
            break;
        case "jump":
            bot.setControlState("jump", true);
            bot.setControlState("jump", false);
            break;
        case "stop":
            clas.stop();
            break;
        case "maxsearch":
            if (parseInt(msg[1]))
                clas.searchDepth = parseInt(msg[1]);
            console.log("highest possible simulated jumps is " + clas.searchDepth);
            bot.chat("highest possible simulated jumps is " + clas.searchDepth);
            break;
        case "goto":
            if (parseInt(msg[4]))
                clas.searchDepth = parseInt(msg[4]);
            if (msg.length === 2) {
                const entity = bot.nearestEntity((e) => { var _a, _b; return !!((_a = e.username) === null || _a === void 0 ? void 0 : _a.includes(msg[1])) || !!((_b = e.name) === null || _b === void 0 ? void 0 : _b.includes(msg[1])); });
                if (!entity)
                    return;
                const goal = goals_1.GoalFactory.gotoEntity(bot, entity);
                clas.goto(goal);
            }
            else {
                const goal1 = goals_1.GoalFactory.gotoPos(bot, new vec3_1.Vec3(parseInt(msg[1]), parseInt(msg[2]), parseInt(msg[3])));
                clas.goto(goal1);
            }
            break;
        case "follow":
            const entity = bot.nearestEntity((e) => { var _a, _b; return !!((_a = e.username) === null || _a === void 0 ? void 0 : _a.includes(msg[1])) || !!((_b = e.name) === null || _b === void 0 ? void 0 : _b.includes(msg[1])); });
            if (!entity)
                return;
            const goal2 = goals_1.GoalFactory.followEntity(bot, entity, parseInt(msg[2]));
            if (parseInt(msg[3]))
                clas.searchDepth = parseInt(msg[3]);
            clas.goto(goal2);
            break;
        case "predict":
            const predictEntity = bot.nearestEntity((e) => { var _a, _b; return !!((_a = e.username) === null || _a === void 0 ? void 0 : _a.includes(msg[1])) || !!((_b = e.name) === null || _b === void 0 ? void 0 : _b.includes(msg[1])); });
            if (!predictEntity)
                return;
            const goal3 = goals_1.GoalFactory.predictEntity(bot, predictEntity, parseInt(msg[2]), 10);
            if (parseInt(msg[3]))
                clas.searchDepth = parseInt(msg[3]);
            clas.goto(goal3);
            break;
    }
}
bot.on("chat", parseMessage);
