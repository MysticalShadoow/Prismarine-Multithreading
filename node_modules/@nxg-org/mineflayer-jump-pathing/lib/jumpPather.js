"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JumpPathing = void 0;
const vec3_1 = require("vec3");
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const events_1 = __importDefault(require("events"));
const constants_1 = require("./constants");
const { PlayerState } = require("prismarine-physics");
// interface Controls {
//     forward: boolean,
//     back: boolean,
//     left: boolean,
//     right: boolean,
//     jump: boolean,
//     sprint: boolean,
//     sneak: boolean
// }
//TODO: Write goal classes instead of manually defining.
//TODO: Perhaps write a better prediction algorithm? this one already works pretty flawlessly.
//TODO: Incorporate *actual* pathfinding. Lol.
function GoalToPosDist(target, origin) {
    return mineflayer_util_plugin_1.AABBUtils.getEntityAABBRaw({ position: target, height: 1.8, width: 0.6 }).distanceToVec(origin);
}
class JumpPathing extends events_1.default {
    constructor(bot) {
        super();
        this.bot = bot;
        this.perTick = () => {
            var _a;
            if (this.bot.entity.onGround && ((_a = this.goal) === null || _a === void 0 ? void 0 : _a.dynamic)) {
                this.resetInfo();
                this.simulateJump(new PlayerState(this.bot, constants_1.forwardSprintJump), this.searchDepth);
            }
            if (this.nextLandingPosition) {
                this.bot.setControlState("forward", true);
                this.bot.setControlState("sprint", true);
                this.bot.setControlState("jump", true);
                this.bot.lookAt(this.nextLandingPosition.offset(0, 1.6, 0), true);
            }
        };
        //manually called for non-dynamic goals.
        this.performJumps = () => __awaiter(this, void 0, void 0, function* () {
            if (this.plannedJumps.length === 0) {
                this.resetInfo();
                this.emit("invalidPath", this.goal);
                return;
            }
            while (this.bot.entity.position.distanceTo(this.plannedJumps[0]) > 1) {
                if (this.bot.entity.onGround) {
                    this.resetInfo();
                    this.simulateJump(new PlayerState(this.bot, constants_1.forwardSprintJump), this.searchDepth);
                }
                if (this.nextLandingPosition && this.goal) {
                    this.bot.setControlState("forward", true);
                    this.bot.setControlState("sprint", true);
                    this.bot.setControlState("jump", true);
                    this.bot.lookAt(this.nextLandingPosition.offset(0, 1.6, 0), true);
                }
                yield this.bot.waitForTicks(1);
            }
            this.resetInfo();
            this.emit("reachedGoal", this.goal);
        });
        this.searchDepth = 2;
        this.goal = null;
        this.plannedJumps = [];
        this.potentialLandingPositions = [];
        this.on("reachedGoal", this.stop);
    }
    goto(goal) {
        this.goal = goal;
        if (this.goal.dynamic) {
            this.bot.on("physicsTick", this.perTick);
            this.bot.tracker.trackEntity(this.goal.target);
        }
        else {
            this.resetInfo();
            this.simulateJump(new PlayerState(this.bot, constants_1.forwardSprintJump), this.searchDepth);
            this.performJumps();
        }
    }
    stop() {
        this.bot.removeListener("physicsTick", this.perTick);
        this.resetEverything();
    }
    resetInfo() {
        this.plannedJumps = [];
        this.potentialLandingPositions = [];
        this.nextLandingPosition = undefined;
    }
    resetEverything() {
        this.resetInfo();
        this.bot.clearControlStates();
    }
    simulateJump(playerState, searchDepth, parentJumpPos) {
        if (!this.goal)
            return;
        let bestLandingPos;
        const targetPos = this.goal.goalPos;
        const deltaPos = targetPos.minus(playerState.pos);
        //assign new yaw for base state.
        playerState.yaw = Math.atan2(-deltaPos.x, -deltaPos.z);
        // begin testing potential jumps from offset of ideal yaw.
        for (let testYaw = playerState.yaw - constants_1.PIOver2; testYaw < playerState.yaw + constants_1.PIOver2; testYaw += constants_1.PIOver8) {
            const stateCopy = JSON.parse(JSON.stringify(playerState)); //deep clone.
            stateCopy.pos = new vec3_1.Vec3(stateCopy.pos.x, stateCopy.pos.y, stateCopy.pos.z);
            stateCopy.vel = new vec3_1.Vec3(stateCopy.vel.x, stateCopy.vel.y, stateCopy.vel.z);
            stateCopy.yaw = testYaw;
            // simulate for thirty ticks.
            for (let ticks = 0; ticks < 30; ticks++) {
                this.bot.physics.simulatePlayer(stateCopy, this.bot.world); //patch later
                if (stateCopy.onGround || stateCopy.isInWater || stateCopy.isInLava)
                    break;
            }
            // append good jump and leave open for potential children jumps.
            if (stateCopy.onGround)
                this.potentialLandingPositions.push({ state: stateCopy, parent: parentJumpPos, open: true });
        }
        this.potentialLandingPositions = this.potentialLandingPositions.filter((a) => a.open);
        if (this.potentialLandingPositions.length > 0) {
            // get most promising state. (closest by distance)
            bestLandingPos = this.potentialLandingPositions.sort((a, b) => GoalToPosDist(targetPos, a.state.pos) - GoalToPosDist(targetPos, b.state.pos))[0];
            // decide whether state is good enough OR decide to stop searching due to max search count
            if (GoalToPosDist(targetPos, bestLandingPos.state.pos) < 1.5 || searchDepth <= 0) {
                // push to jumpTargets the jumps necessary to reach the goal, up to allowed limit / cut-off point.
                let searcher = bestLandingPos;
                while (searcher.parent) {
                    this.plannedJumps.push(searcher.state.pos);
                    searcher = searcher.parent;
                }
                this.plannedJumps.push(searcher.state.pos);
                this.nextLandingPosition = searcher.state.pos;
            }
            else if (searchDepth > 0) {
                //close off parent so no children are searched from this node.
                bestLandingPos.open = false;
                this.simulateJump(bestLandingPos.state, searchDepth - 1, bestLandingPos);
            }
        }
        else {
            // this.bot.chat("nothing to jump on...");
            this.emit("pathingFailed", "lava_or_water");
        }
    }
}
exports.JumpPathing = JumpPathing;
