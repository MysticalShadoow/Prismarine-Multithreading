"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseGoal = exports.EntityGoalPredictive = exports.EntityGoalDynamic = exports.StaticGoal = exports.BaseGoal = void 0;
const events_1 = __importDefault(require("events"));
const vec3_1 = require("vec3");
class BaseGoal extends events_1.default {
    constructor(bot, target, dynamic, predictive) {
        super();
        this.bot = bot;
        this.target = target;
        this.dynamic = dynamic;
        this.predictive = predictive;
    }
}
exports.BaseGoal = BaseGoal;
class StaticGoal extends BaseGoal {
    constructor(bot, target) {
        super(bot, target, false, false);
        this.target = target;
    }
    get goalPos() {
        return this.target;
    }
    get goalPosRaw() {
        return this.target;
    }
    goalReached() {
        return this.bot.entity.position.floored().equals(this.goalPos);
    }
}
exports.StaticGoal = StaticGoal;
class EntityGoalDynamic extends BaseGoal {
    constructor(bot, target, wantedDistance = 1) {
        super(bot, target, false, false);
        this.target = target;
        this.wantedDistance = wantedDistance;
    }
    get goalPos() {
        return this.target.position;
    }
    get goalPosRaw() {
        return this.target.position;
    }
    goalReached() {
        const { x, y, z } = this.goalPos;
        const dx = x - this.bot.entity.position.x;
        const dy = y - this.bot.entity.position.y;
        const dz = z - this.bot.entity.position.z;
        return (dx * dx + dy * dy + dz * dz) <= this.wantedDistance;
    }
}
exports.EntityGoalDynamic = EntityGoalDynamic;
class EntityGoalPredictive extends BaseGoal {
    constructor(bot, target, wantedDistance = 1, ticksToPredict = 10, predictiveFunction = (delta, pos, vel) => {
        const base = Math.round(Math.sqrt(Math.pow(delta.x, 2) + Math.pow(delta.y, 2) + Math.pow(delta.z, 2)));
        const tickCount = Math.round((base * this.ticksToPredict) / Math.sqrt(base));
        return pos.plus(vel.scaled(isNaN(tickCount) ? 0 : tickCount));
    }) {
        super(bot, target, true, true);
        this.target = target;
        this.wantedDistance = wantedDistance;
        this.ticksToPredict = ticksToPredict;
        this.predictiveFunction = predictiveFunction;
        this.bot.tracker.trackEntity(target);
    }
    get goalPos() {
        return this.predictiveFunction(this.target.position.minus(this.bot.entity.position), this.target.position, this.bot.tracker.getEntitySpeed(this.target) || new vec3_1.Vec3(0, 0, 0));
    }
    get goalPosRaw() {
        return this.target.position;
    }
    goalReached() {
        const { x, y, z } = this.goalPos;
        const dx = x - this.bot.entity.position.x;
        const dy = y - this.bot.entity.position.y;
        const dz = z - this.bot.entity.position.z;
        return (dx * dx + dy * dy + dz * dz) <= this.wantedDistance;
    }
}
exports.EntityGoalPredictive = EntityGoalPredictive;
class InverseGoal extends BaseGoal {
    constructor(goal) {
        super(goal.bot, goal.target, goal.dynamic, goal.predictive);
        this.goal = goal;
    }
    get goalPos() {
        return this.goal.goalPos;
    }
    get goalPosRaw() {
        return this.goal.goalPosRaw;
    }
    goalReached() {
        return !this.goal.goalReached();
    }
}
exports.InverseGoal = InverseGoal;
